<!DOCTYPE html><html lang="zh-ch"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> runtime 源码学习笔记 · 阿斌的技术博客</title><meta name="description" content="runtime 源码学习笔记 - Abin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.iosgg.cn/atom.xml" title="阿斌的技术博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="阿斌的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/wxiubin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">runtime 源码学习笔记</h1><div class="post-info">Apr 8, 2016</div><div class="post-content"><h2 id="Objc-中类和对象的本质"><a href="#Objc-中类和对象的本质" class="headerlink" title="Objc 中类和对象的本质"></a>Objc 中类和对象的本质</h2><p>Objc 中任何对象都可以称之为 <code>id</code> 类型，那么看下在 <code>objc.h</code> 对 <code>id</code> 类型的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure>

<p>注释中的描述是 <em>一个指向类的实例的指针</em>，那么是不是意味一个类的实例即对象就是一个 <code>objc_object</code> 结构体呢？再看源码：</p>
<a id="more"></a>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa; <span class="comment">// 对象的类信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;          <span class="comment">// 父类</span></span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable；方法缓存列表</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags；类信息存储的地方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读 runtime 的源码可以得出以下结构：</p>
<p><img src="/images/obj-class-isa.png" alt="obj-class-isa"></p>
<blockquote>
<p>注：<code>class_ro_t</code> 中存放的是编译时可以确定的属性、方法和协议等</p>
</blockquote>
<ol>
<li>Objc 中的对象是一个 <code>objc_object</code> 结构体，结构体中第一个变量是 <code>isa_t</code> ，存放着该对象所属类的信息；</li>
<li>类是一个<code>objc_class</code> 结构体，继承自 <code>objc_object</code> ，所以类也是一个对象，另外还有两个变量进行方法缓存和数据存放，比如变量、方法(实例方法，以 <code>-</code> 开头的方法)和所遵守的协议。</li>
<li>类的 <code>isa</code> 中存放的类是元类（meta-class），类是一个对象，对象的类型就是元类，元类存放着类的方法(类方法，以 <code>+</code> 开头的方法)。</li>
<li>元类也是类，所以元类也是对象。元类 <code>isa</code> 变量中存放的类是根元类（一般是 <code>NSObject</code> ）。</li>
<li>根元类 <code>isa</code> 的类信息指向其自身</li>
<li>类和元类都是单例</li>
</ol>
<p>那么 <code>isa</code> 到底存放了什么？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;  <span class="comment">// 是否开启指针优化                                    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否关联对象                                    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有 C++ 自定义析构函数                     </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 存放了类的信息</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">// 验证对象是否初始化完整                                    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">// 是否被弱引用           </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;  <span class="comment">// 是否正在析构                                    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数是否在 sidetable 中存储，当对象的 extra_rc 字段存储不下时，会把引用计数存放在 sidetable 中                     </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>  <span class="comment">// 引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>objc_object</code> 中的 <code>isa</code> 是通过位域+掩码来优化存储。<code>isa</code> 共8个字节64位，其中存放类信息的 <code>shiftcls</code> 占去了 33 位，存放引用计数的 <code>extra_rc</code> 占用了 19 位，验证对象是否初始化完整的 <code>magic</code> 占用 6 位，其他都是只占用了 1 位。</p>
<p>再看下 <code>class_data_bits_t</code> 中 <code>class_rw_t</code> 的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;         <span class="comment">// 编译期决定的类的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;       <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties;  <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;   <span class="comment">// 协议列表</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">    <span class="keyword">uint32_t</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>const class_ro_t *ro</code> 中存放的是类在编译时期就确定的方法、协议等，分类及运行时添加的属性、方法都在 <code>class_rw_t</code> 存储。但是 <code>class_data_bits_t</code> 中的 data（<code>class_rw_t</code>） 一开始是 <code>const class_ro_t *ro;</code>，在初始运行时环境中的 <code>realizeClass</code> 函数中，重新生成 <code>class_rw_t</code> data。并且通过 <code>attachCategories</code> 函数，将分类的方法、协议等添加到 <code>class_rw_t</code> 中。至此，<code>class_rw_t</code> 存放了一个类所需要的完整信息。</p>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><p>调用方法（函数）是语言经常使用的功能，在 Objective-C 中专业一点的叫法是 <strong>传递消息(pass a message)</strong>。Objective-C 的方法调用都是 <strong>动态绑定</strong> ，而C语言中函数调用方式是 <strong>静态绑定</strong>  ( <strong>static binding</strong> )，也就是说，在编译时期就能决定和知道在运行时所调用的函数。</p>
<p>以下面代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayGoodBye</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saySomething</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">		sayHello();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		sayGoodBye();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>基本上，上面的代码在编译的时候编译器就知道 <strong>sayHello</strong> 和 <strong>sayGoodBye</strong> 两个函数的存在，函数地址是硬编码在指令之中的。但是如果换一种写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayGoodBye</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saySomething</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> (*something) ();</span><br><span class="line">	<span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">		something = sayHello;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		something = sayGoodBye;</span><br><span class="line">	&#125;</span><br><span class="line">	something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就得使用 <strong>动态绑定</strong> ，待调用的函数地址需要到运行时才能读取出来。<br>在 Objective-C 中，对某一个对象传递消息，会用动态绑定机制来决定到底是调用哪个方法。而Objective-C是 C 的超集，底层是由 C语言实现，但是对象接收消息后会调用哪个方法都是在运行期决定。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> object = [list objectAtIndex:<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>在这行代码中， <strong>list</strong> 称为 <strong>接收者</strong>， <strong>objectAtIndex</strong> 叫做 <strong>选择器</strong>， 选择器和参数合起来称为<strong>消息</strong>。当编译器看到这行代码的时候，会换成标准的C语言函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_msgSend</span><span class="params">(id self, SEL cmd, ...)</span></span>;</span><br><span class="line">id lastObject = objc_msgSend(<span class="built_in">list</span>, @selector(objectAtIndex:), parameter);</span><br></pre></td></tr></table></figure>

<p><strong>objc_msgSend</strong> 这个函数可以接收两个及两个以上的参数，第一个参数是接收者，第二个参数是选择器，后面的参数是保持顺序的原来消息传递的参数，<strong>objc_msgSend</strong> 会依据接收者和选择器来决定调用哪个方法，首先在接收者的方法列表缓存（<code>objc_class/cache_t cache</code>）中寻找，如果方法缓存中找不到就类信息存储的方法列表（<code>objc_class/class_data_bits_t/class_rw_t/methods</code>）中找，如果再找不到就会沿着继承体系（<code>objc_class/superclass/class_data_bits_t/class_rw_t/methods</code>）去向上一层一层的寻找，如果仍旧找不到就会执行 <strong>消息转发(message forwarding)</strong> 。<br>当消息第一次传递之后，objc_msgSend 会将匹配结果进行缓存（<code>objc_class/cache_t cache</code>），下次会直接调用方法。消息传递除了objc_msgSend之外在特殊情况下还会有其他的方法来处理：</p>
<ul>
<li><strong>objc_msgSend_stret</strong> 如果待发送的消息返回一个结构体，就会调用这个函数来处理。</li>
<li><strong>objc_msgSend_fpret</strong> 如果消息返回的是浮点数，就会调用这个函数进行处理。</li>
<li><strong>objc_msgSendSuper</strong> 如果要传递消息给父类。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>消息由 接收者、选择器及参数构成，给某对象 <strong>发送消息( invoke a message )</strong> 也就相当于在该对象上调用方法。</li>
<li>发送给某对象的全部消息都要有<strong>动态消息派发系统( dynamic message dispatch system )</strong> 来处理。</li>
</ul>
<h2 id="Objective-C-的消息转发机制与动态添加方法"><a href="#Objective-C-的消息转发机制与动态添加方法" class="headerlink" title="Objective-C 的消息转发机制与动态添加方法"></a>Objective-C 的消息转发机制与动态添加方法</h2><p>刚才说了运行时的消息传递机制，但是却没有说对象收到消息却无法解读该怎么办。这里就着重介绍当消息传递时无法解读的时候就会启动的 <strong>消息转发机制( message forwarding )</strong>。</p>
<p>开发可能经常会遇到这种情况：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-04</span><span class="number">-20</span> <span class="number">13</span>:<span class="number">14</span>:<span class="number">07.391</span> runtime[<span class="number">1096</span>:<span class="number">22076</span>] *** Terminating app due to uncaught exception <span class="string">'NSInvalidArgumentException'</span>, reason: <span class="string">'-[AutoDictionary setDate:]: unrecognized selector sent to instance 0x100302f50'</span></span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">	<span class="number">0</span>   CoreFoundation                      <span class="number">0x00007fff9f2d94f2</span> __exceptionPreprocess + <span class="number">178</span></span><br><span class="line">	<span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x00007fff90db3f7e</span> objc_exception_throw + <span class="number">48</span></span><br><span class="line">	<span class="number">2</span>   CoreFoundation                      <span class="number">0x00007fff9f3431ad</span> -[<span class="built_in">NSObject</span>(<span class="built_in">NSObject</span>) doesNotRecognizeSelector:] + <span class="number">205</span></span><br><span class="line">	<span class="number">3</span>   CoreFoundation                      <span class="number">0x00007fff9f249571</span> ___forwarding___ + <span class="number">1009</span></span><br><span class="line">	<span class="number">4</span>   CoreFoundation                      <span class="number">0x00007fff9f2490f8</span> _CF_forwarding_prep_0 + <span class="number">120</span></span><br><span class="line">	<span class="number">5</span>   runtime                             <span class="number">0x0000000100001c1c</span> main + <span class="number">124</span></span><br><span class="line">	<span class="number">6</span>   libdyld.dylib                       <span class="number">0x00007fff91df85ad</span> start + <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type <span class="built_in">NSException</span></span><br></pre></td></tr></table></figure>

<p>这个异常信息是由 <strong>NSObject</strong> 的 <strong>doesNotRecognizeSelector:</strong> 方法抛出来的，本来是给 <strong>AutoDictionary</strong> 的一个实例对象发送消息，但是该对象并没有 <strong>setDate:</strong> 方法，所以消息转发给了 <strong>NSObject</strong> ，最后抛出异常。</p>
<p>先看下消息处理机制流程图：</p>
<p><img src="/images/c1f0660ejw1f51rg5hbhuj213k0is40f.jpg" alt="消息处理机制流程图"></p>
<p>消息转发分为两阶段三步，第一阶段先看接受消息的对象能不能自己处理这个无法解读的消息，这一步可以动态的添加方法去解读接受这个消息；第二阶段是先看看对象自己不能处理这个消息，能不能交给其他对象来进行处理，在这一步如果仍然无法解读消息，那么就会走最后一步：把和消息有关的所有细节封装到一个 <strong>NSInvocation</strong> 中，再询问一次对象是否能解决。<br>看下三个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 询问对象是否自己处理，是返回YES，一般会在这个方法里面动态添加方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步询问对象把消息交给哪个对象来进行处理</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果走到这一步的话，就把消息的所有信息封装成 NSInvocation 对象进行 "最后通牒"</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure>

<p>来一段代码示例：<br>新建一个 <strong>AutoDictionary</strong> 类，添加一个 <strong>NSDate</strong> 类型的 <strong>date</strong> 属性，在实现文件里面用 <strong>@dynamic date;</strong> 禁止自动生成存取方法，这样当代码中给 <strong>AutoDictionary</strong> 实例对象的 <strong>date</strong>属性赋值时就会出现消息无法解读的现象。<br><strong>.h</strong> 文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AutoDictionary</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>.m</strong> 实现文件代码内容：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AutoDictionary</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *backingStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  该类仅在实现文件 实现了</span></span><br><span class="line"><span class="comment"> *  - (NSDate *)date</span></span><br><span class="line"><span class="comment"> *  - (void)setDate:(NSDate *)date</span></span><br><span class="line"><span class="comment"> *  两个方法，用于处理 AutoDictionary 无法解读的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) MethodCreator *methodCreator;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AutoDictionary</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">@dynamic</span> date;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.backingStore = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="keyword">self</span>.methodCreator = [MethodCreator new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 消息转发机制 ：1.动态添加方法 2.后备消息接收者 3.封装NSInvocation，最后通牒</span></span><br><span class="line"><span class="comment">// 3. 封装NSInvocation，最后通牒</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 无法接受消息，选择由谁来接受</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.methodCreator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 动态添加方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selString hasPrefix:<span class="string">@"set"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoDictSetter, <span class="string">""</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoDictGetter, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">id</span> autoDictGetter (<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123;</span><br><span class="line">    AutoDictionary *dict = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="keyword">return</span> [dict.backingStore objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> autoDictSetter (<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> value)&#123;</span><br><span class="line">    AutoDictionary *dict = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="built_in">NSString</span> *key = [selString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">3</span>, selString.length<span class="number">-4</span>)];</span><br><span class="line">    key = [key lowercaseStringWithLocale:[<span class="built_in">NSLocale</span> currentLocale]];</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        [dict.backingStore setObject:value forKey:key];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [dict.backingStore removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AutoDictionary *dict = [AutoDictionary new];</span><br><span class="line">dict.date = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"dict.date = %@"</span>,dict.date);</span><br></pre></td></tr></table></figure>



<h2 id="method-swizzling-与AOP编程"><a href="#method-swizzling-与AOP编程" class="headerlink" title="method swizzling 与AOP编程"></a>method swizzling 与AOP编程</h2><p>什么是 <code>AOP</code> : (site: baike.baidu.com)，引用百度百科中的解释就是：</p>
<p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<blockquote>
<p>主要功能:<br>日志记录，性能统计，安全控制，事务处理，异常处理等等</p>
<p>主要意图:<br>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p>
</blockquote>
<p><strong>iOS 开发中的 AOP</strong><br>在 <strong>Objective-C</strong> 中，类的方法列表会把选择器的名称映射到方法的实现上，这样 <strong>动态消息转发系统</strong> 就可以以此找到需要调用的方法。这些方法是以函数指针的形式来表示，这种指针叫做 <strong>IMP</strong>。<br>如下：</p>
<p><img src="/images/c1f0660ejw1f51w4zipmhj20c5052glu.jpg" alt="c1f0660ejw1f51w4zipmhj20c5052glu"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> (*IMP) (<span class="keyword">id</span>, SEL, ...)</span><br></pre></td></tr></table></figure>

<p><code>Objective-C</code> 的 <code>runtime</code> 机制以此提供了获取和交换映射<code>IMP</code>的的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name)；</span><br><span class="line"><span class="comment">// 交换两个方法</span></span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations(Method m1, Method m2)</span><br></pre></td></tr></table></figure>

<p>我们可以通过上面两个方法来进行选择器和所映射的<code>IMP</code>进行交换：</p>
<p><img src="/images/c1f0660ejw1f51w5m2wipj20c008874r.jpg" alt="c1f0660ejw1f51w5m2wipj20c008874r"></p>
<p>来，直接上代码示例，比如我们的要实现功能是在每个控制器的<code>- viewDidLoad</code>方法里面log一下，一般有三种实现方式：</p>
<ol>
<li>直接修改每个页面的 <strong>view controller</strong> 代码，简单粗暴；</li>
<li>子类化 <strong>view controller</strong> ，并让我们的 <strong>view controller</strong> 都继承这些子类；</li>
<li>使用 <code>Method Swizzling</code> 进行 hook，以达到 <code>AOP</code> 编程的思想</li>
</ol>
<p>第一种实现的代码是在每个类的里面都这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    DDLog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是只在基类里面写。然后所有的控制器都继承这个基类。<br>最后一种是最佳的解决方案：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Log</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewDidLoad);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(log_viewDidLoad);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">BOOL</span> success = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Method Swizzling</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)log_viewDidLoad&#123;</span><br><span class="line">    [<span class="keyword">self</span> log_viewDidLoad];</span><br><span class="line">    DDLog(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> </p>
<ul>
<li>为什么使用 <code>+ (void)load</code> ？因为父类、子类和分类的该方法是分别调用，互不影响，而且是在类被加载的时候必定会调用的方法。</li>
</ul>
<p>那么为什么说“父类、子类和分类的该方法是分别调用”且”类被加载的时候必定会调用的方法“呢？</p>
<p>在 runtime 源码中的 <code>_objc_init() -&gt; load_images() -&gt; call_load_methods()</code> 函数里，可以发现load方法不是走的消息发送，而是直接使用函数地址指针直接调用，且保证了类的load方法在分类之前调用，父类的load方法再子类之前调用。具体逻辑见伪代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">    <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        call_class_loads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">    more_categories = call_category_loads();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给对象、分类添加实例变量"><a href="#给对象、分类添加实例变量" class="headerlink" title="给对象、分类添加实例变量"></a>给对象、分类添加实例变量</h2><p> 在开发中有时候想给对象实例添加个变量来存储数据，但又无法直接声明，比如说既有类的分类。这个时候我们就可以通过 <strong>关联对象</strong> 在运行时给对象关联一个 <strong>对象</strong> 来存储数据。（注意：并不是真实的添加了一个实例变量）</p>
<p><strong>关联对象</strong> 可以给某个对象关联其他对象并用<strong>key</strong>来区分其他对象。需要注意的是，存储对象的时候要指明 <strong>存储策略</strong>，用来维护对象的内存管理语义。存储策略是 <strong>objc_AssociationPolicy</strong> 枚举定义，以下是存储策略对应的 <strong>@property</strong>属性：</p>
<table>
<thead>
<tr>
<th>存储策略类型</th>
<th>对应的@property属性</th>
</tr>
</thead>
<tbody><tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>weak</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>strong, nonatomic</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>copy, nonatomic</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>strong</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>copy</td>
</tr>
</tbody></table>
<!--more-->

<p>用下面的方法可以管理关联对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以根据指定策略给对象关联对象值</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法可以获取对象关联对象值</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法可以删除指定对象的全部关联对象值</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>定义关联对象时需要指定内存管理语义，用来模拟对象对变量的拥有关系</li>
<li>尽量避免使用关联对象，因为如果出现bug不易于问题排查</li>
</ul>
<p><strong>Associated Object的实现方式</strong></p>
<p><img src="/images/associations.png" alt="associations.png"></p>
<p>通过源码发现，存储使用的数据结构如上图所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">                              id value,</span></span></span><br><span class="line"><span class="function"><span class="params">                              objc_AssociationPolicy policy)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>AssociationsManager</code> 类中有个静态变量 <code>AssociationsHashMap *_map</code></li>
<li><code>AssociationsHashMap</code> 中以 <code>object</code> 为 key，value 是 <code>ObjectAssociationMap</code></li>
<li><code>ObjectAssociationMap</code> 中 key 就是入参 <code>key</code>，value 就是入参 <code>value</code></li>
</ol>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>做个试验，新建一个 <code>BBObject</code> 类，添加一个属性 <code>bb_name</code>，头文件如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BBObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *bb_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>那么以下代码会输出什么呢：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *name = <span class="string">@"这是 bb_name"</span>;</span><br><span class="line"><span class="keyword">void</span> *cls = (__bridge <span class="keyword">void</span> *)([BBObject <span class="keyword">class</span>]);</span><br><span class="line"><span class="keyword">void</span> *bb_obj = &amp;cls;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[(__bridge BBObject*)bb_obj bb_name]);</span><br></pre></td></tr></table></figure>

<p>输出的是：<code>2017-12-16 19:55:33.477716+0800 runtime[45876:7116185] 这是 bb_name</code>。</p>
<p>因为 Objc 中一个完整的对象就是 <strong>首地址指向一个类的连续空间</strong>，为什么是连续空间？那是因为对象还有自己属性变量的值要存储，这也是为什么没有给 <code>bb_obj</code> 的 <code>bb_name</code> 属性赋值，却打印出 <code>name</code> 值的原因，在 iOS 中，栈的地址是由高到低，堆的地址是由低到高，在这段代码中栈中依次压入了 <code>name</code>、<code>bb_obj</code>，而 <code>bb_obj</code> 对象自身的属性是根据自身首地址进行偏移去获取，所以会取到 <code>name</code> 的值。</p>
<p><img src="/images/objc_ivar.png" alt="objc_iva"></p>
<p>使用 <code>clang -rewrite-objc BBObject.m</code> 可以把得到重写后的 C++ 文件，在其中也可以看到其中获取属性就是自身地址加偏移量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * _I_BBObject_bb_name(BBObject * <span class="keyword">self</span>, SEL _cmd) &#123; </span><br><span class="line">    <span class="keyword">return</span> (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_BBObject$_bb_name)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2016/05/22/5-multithreading_iOS/" class="prev">PREV</a><a href="/2016/03/27/3-make-blog-use-githubPages-hexo/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2022 <a href="http://blog.iosgg.cn">Abin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/m-forks/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-100885072-1",'auto');ga('send','pageview');</script></body></html>