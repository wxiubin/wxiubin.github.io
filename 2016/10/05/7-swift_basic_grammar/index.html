<!DOCTYPE html><html lang="zh-ch"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Swift 语法初窥 · 阿斌的技术博客</title><meta name="description" content="Swift 语法初窥 - Abin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.iosgg.cn/atom.xml" title="阿斌的技术博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="阿斌的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/wxiubin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Swift 语法初窥</h1><div class="post-info">Oct 5, 2016</div><div class="post-content"><p><strong>References：</strong> <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309" target="_blank" rel="noopener">The Swift Programming Language</a></p>
<blockquote>
<p>某程序员对书法十分感兴趣，退休后决定在这方面有所建树。于是花重金购买了上等的文房四宝。一日，饭后突生雅兴，一番磨墨拟纸，并点上了上好的檀香，颇有王羲之风范，又具颜真卿气势，定神片刻，泼墨挥毫，郑重地写下一行字：<code>hello world</code>。</p>
</blockquote>
<a id="more"></a>

<br>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, World"</span>)</span><br></pre></td></tr></table></figure>

<!--more-->

<h2 id="Swift-的基础语法"><a href="#Swift-的基础语法" class="headerlink" title="Swift 的基础语法"></a>Swift 的基础语法</h2><h3 id="值与类型"><a href="#值与类型" class="headerlink" title="值与类型"></a>值与类型</h3><p>定义变量用 <code>var</code>，常量用 <code>let</code>。常量只能赋值一次，但不用必须在声明的时候去赋值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVariable = <span class="number">42</span></span><br><span class="line">myVariable = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myConstant = <span class="number">42</span></span><br></pre></td></tr></table></figure>



<p>编译器会自动推断常量和变量的类型，但是如果推断不出来（比如说没有初始值等），就需要声明类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> helloTalk : <span class="type">String</span></span><br><span class="line">helloTalk = <span class="string">"helloTalk"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> helloTalk = <span class="string">"helloTalk"</span></span><br></pre></td></tr></table></figure>

<p><strong>Swift</strong>的值不会隐式被转为其他类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> widthFloat = <span class="number">93.33</span>          <span class="comment">// 自动推断 为 Double</span></span><br><span class="line"><span class="keyword">let</span> width : <span class="type">Int</span> = widthFloat    <span class="comment">// 把 Double 赋值给 Int，会报错</span></span><br><span class="line"><span class="keyword">let</span> widthLabel = label + <span class="type">String</span>(width)</span><br><span class="line"><span class="comment">// 把值转换成字符串还可以这样： \(ValueName)</span></span><br><span class="line"><span class="keyword">let</span> widthString = <span class="string">"width: \(width)."</span></span><br></pre></td></tr></table></figure>

<p><strong>创建、定义一个数组或者字典</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray = [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">let</span> emptyDictionary = [<span class="type">String</span>: <span class="type">Float</span>]()</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> emptyArray = []</span><br><span class="line"><span class="keyword">let</span> emptyDictionary = [:]</span><br></pre></td></tr></table></figure>

<p>数组和字典都是集合类型，对于这种类型的 <code>let</code> 和 <code>var</code> 修饰并非是像普通值的可否赋值。<br>比如说，用 <code>let</code> 修饰的数组是不能添加和移除数组中的元素，数组中的元素个数、位置均不可变，但是用 <code>var</code> 修饰的数组可以添加/删除元素。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举是为一组相关的值定义了一个共同类型，在 <code>Swift</code> 中，枚举是“一等公民”。枚举成员的原始值不仅可以是整形，还可以是字符、字符串、浮点型；此外，枚举还支持属性、方法、甚至是构造函数、扩展和遵守协议。</p>
<p>用 <code>enum</code> 关键词来创建枚举：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者用逗号分隔写作一行：</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> direction: <span class="type">Direction</span> = .west</span><br></pre></td></tr></table></figure>

<p><strong>原始值</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north = <span class="string">"北"</span></span><br><span class="line">    <span class="keyword">case</span> south = <span class="string">"南"</span></span><br><span class="line">    <span class="keyword">case</span> east = <span class="string">"东"</span></span><br><span class="line">    <span class="keyword">case</span> west = <span class="string">"西"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> north = <span class="type">Direction</span>.north     <span class="comment">// the sanme as : let north = Direction(rawValue: "北")</span></span><br><span class="line">north.rawValue  <span class="comment">// "北"</span></span><br></pre></td></tr></table></figure>

<p><strong>关联值</strong></p>
<p>Swift 的枚举可以存储各个类型的关联值，而且每个成员的类型可以都不一样。所以对于一个网络请求可以有这样的抽象：一个网络请求的<em>结果</em>，可以是<em>成功</em>或者<em>失败</em>的，如果成功则返回的是我们想要的<em>数据</em>，不成功返回<em>错误原因</em>，那么可以写成这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Value</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Value</code> 是泛型语法，可以是任何你需要的类型。</p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p> <strong>for-in</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> persons = [<span class="string">"person1"</span>,<span class="string">"person2"</span>]</span><br><span class="line"><span class="keyword">for</span> personString <span class="keyword">in</span> persons &#123;</span><br><span class="line">  <span class="built_in">print</span>(personString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历字典</span></span><br><span class="line"><span class="keyword">let</span> dict = [</span><br><span class="line">            <span class="string">"name"</span> : <span class="string">"Joke"</span>,</span><br><span class="line">            <span class="string">"age"</span>  : <span class="number">16</span></span><br><span class="line">        ] <span class="keyword">as</span> [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> (key,value) <span class="keyword">in</span> dict &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(key) : \(value)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>if-else</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2</span>&gt;<span class="number">1</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"2 大于 1"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"2 还是大于 1 啊"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code> 后面必须是布尔表达式，如果是一个值的话不会隐式的与 0 比较。</p>
<p><strong>switch</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable = <span class="string">"red pepper"</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"celery"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Add some raisins and make ants on a log."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cucumber"</span>, <span class="string">"watercress"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"That would make a good tea sandwich."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"pepper"</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Is it a spicy \(x)?"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Everything tastes good in soup."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 不仅支持基本数据类型。另外Swift中的<code>switch</code>语法可以省略<code>break</code>。但是不能省略 <code>default</code>，会报 <code>Switch must be exhaustive, consider adding a default clause</code> 的编译错误。</p>
<p><strong>while</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">100</span> &#123;</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">while</span> i &lt; <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="Swift-的函数和闭包"><a href="#Swift-的函数和闭包" class="headerlink" title="Swift 的函数和闭包"></a>Swift 的函数和闭包</h2><p>函数的关键字是 <code>func</code> ，函数定义的格式是：</p>
<p><img src="/images/swift-function.png" alt="swift-function"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(para:paraType)</span></span> -&gt; returnType&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数的参数标签"><a href="#函数的参数标签" class="headerlink" title="函数的参数标签"></a>函数的参数标签</h3><p>其中参数的那部分的详细结构是用小括号括起来，参数名，冒号，参数类型： <code>(number:Int)</code>。<br>在默认情况下，函数的参数标签使用参数名，或者用 <code>_</code> 不使用参数标签，也可以自定义标签，我们定义一个奇葩的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 求和<span class="params">(数字<span class="number">1</span> num1:Float, 数字<span class="number">2</span> num2:Float)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求和</strong> 就是方法名，<strong>数字1</strong> 就是自定义的参数标签。调用时会显示标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = 求和(数字<span class="number">1</span>: <span class="number">2</span>, 数字<span class="number">2</span>: <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><p><code>swift</code> 还可以用元组返回多个返回值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(numarray:<span class="params">([Int])</span></span></span>) -&gt; (<span class="built_in">min</span>:<span class="type">Int</span>, <span class="built_in">max</span>:<span class="type">Int</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> <span class="built_in">min</span> = numarray[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">var</span> <span class="built_in">max</span> = numarray[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">for</span> num <span class="keyword">in</span> numarray &#123;</span><br><span class="line">       <span class="keyword">if</span> num &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">           <span class="built_in">max</span> = num</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="built_in">min</span>&#123;</span><br><span class="line">           <span class="built_in">min</span> = num</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (<span class="built_in">min</span>, <span class="built_in">max</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时获取返回值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compare(numarray: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).<span class="built_in">max</span></span><br></pre></td></tr></table></figure>

<h3 id="函数嵌套函数"><a href="#函数嵌套函数" class="headerlink" title="函数嵌套函数"></a>函数嵌套函数</h3><p><code>swift</code> 语法中函数可以嵌套函数，用于分割太长或者太复杂的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要在意逻辑，只是为了示例一下。。。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumWithArray</span><span class="params">(numArray:<span class="params">([Int])</span></span></span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(num1:Int, num2:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> num1 + num2</span><br><span class="line">   &#125;</span><br><span class="line">   sum = add(num1: numArray[<span class="number">0</span>], num2: numArray[<span class="number">1</span>])</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回一个函数"><a href="#返回一个函数" class="headerlink" title="返回一个函数"></a>返回一个函数</h3><p>函数还可以用一个函数做为返回值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMethod</span><span class="params">()</span></span> -&gt; ((<span class="type">Int</span>)-&gt;(<span class="type">Int</span>)) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(num:Int)</span></span>-&gt;(<span class="type">Int</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> num+<span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> addOne</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"makeMethod()(1993): "</span>,makeMethod()(<span class="number">1993</span>))</span><br><span class="line"><span class="comment">// makeMethod()(1993):  1994</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">makeMethod() 返回的是一个函数，继续传入参数 1993，最后返回 1994</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="传入一个函数"><a href="#传入一个函数" class="headerlink" title="传入一个函数"></a>传入一个函数</h3><p>函数可以把一个函数当做返回值返回，也可以当做一个参数来传入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfMaxMin</span><span class="params">(numarray:<span class="params">([Int])</span></span></span>,compare:(<span class="number">_</span> numarray:([<span class="type">Int</span>]))-&gt;(<span class="built_in">min</span>:<span class="type">Int</span>, <span class="built_in">max</span>:<span class="type">Int</span>)) -&gt; (<span class="type">Int</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> compare(numarray).<span class="built_in">max</span> + compare(numarray).<span class="built_in">min</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到， <code>sumOfMaxMin</code> 函数有两个参数：<code>numarray:([Int])</code> 和 <code>compare:(_ numarray:([Int]))-&gt;(min:Int, max:Int)</code> 。其中 <code>compare</code> 是一个函数。</p>
<p>在调用的时候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfMaxMinValue = sumOfMaxMin(numarray: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],compare: compare)</span><br></pre></td></tr></table></figure>

<p><code>compare</code> 是上个例子中的函数。当然，我们也可以不传入一个现成已经定义和实现的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfMaxMinValue = sumOfMaxMin(numarray: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) &#123; (numarray:([<span class="type">Int</span>])) -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">min</span> = numarray[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">max</span> = numarray[<span class="number">0</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> num <span class="keyword">in</span> numarray &#123;</span><br><span class="line">      <span class="keyword">if</span> num &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">          <span class="built_in">max</span> = num</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="built_in">min</span>&#123;</span><br><span class="line">          <span class="built_in">min</span> = num</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">min</span>, <span class="built_in">max</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数是一种特殊的闭包"><a href="#函数是一种特殊的闭包" class="headerlink" title="函数是一种特殊的闭包"></a>函数是一种特殊的闭包</h3><p>大家伙看到这里，肯定会一拍大腿：哎呦，这玩意不就是闭包嘛！</p>
<blockquote>
<p>（The Swift Programming Language）函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 </p>
</blockquote>
<p>我们可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型声明与闭包函数体进行分离。 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] </span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;</span><br><span class="line">  (num:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> newNum = num * <span class="number">3</span></span><br><span class="line">  <span class="keyword">return</span> newNum</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="闭包的简写"><a href="#闭包的简写" class="headerlink" title="闭包的简写"></a>闭包的简写</h3><p>如果闭包的类型已知，那么可以省略参数和返回值的类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;</span><br><span class="line">  num <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> newNum = num * <span class="number">3</span></span><br><span class="line">  <span class="keyword">return</span> newNum</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>单个语句闭包会把它语句的值当做结果返回</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;</span><br><span class="line">  num <span class="keyword">in</span></span><br><span class="line">  num * <span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果把上面的闭包写成一行的话</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;num <span class="keyword">in</span> num * <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>我们可以通过参数位置而不是参数名字来引用参数，那么上面的代码就变成这样</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;$<span class="number">0</span> * <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>当一个闭包是传给函数的唯一参数，我们可以完全忽略括号 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>&#123;$<span class="number">0</span> * <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Swift-的类和对象"><a href="#Swift-的类和对象" class="headerlink" title="Swift 的类和对象"></a>Swift 的类和对象</h2><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>类定义的关键字是 <code>class</code>，我们用 <code>class</code> + <strong>类名</strong> + “<strong>:</strong>“ + <strong>父类</strong>，比如定义一个 <code>Person</code> 类，类中去声明和定义变量和函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello ~"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类的扩展</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;  <span class="comment">// 给人加一个飞的功能...</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h4><p>存储属性就是存储在类或者结构体一个实例里的一个常量和变量，用 <code>var</code> 或者 <code>let</code> 修饰。</p>
<p>但是如果一个结构体实例被声明为常量，那么即便这个结构体的某个属性是变量，也是不能去改变的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line">point.x = <span class="number">10</span>    <span class="comment">// 编译是不会通过的</span></span><br></pre></td></tr></table></figure>

<p><strong>延迟存储属性</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> nameLabel:<span class="type">UILabel</span> = &#123;</span><br><span class="line">   <span class="keyword">let</span> label = <span class="type">UILabel</span>()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> label</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>其实就是把一个立即执行的闭包的返回值赋值给属性，以达到懒加载的目的。</p>
<p><strong>属性观察器</strong></p>
<p><code>willSet</code> 在新的值被设置之前调用<br><code>didSet</code> 在新的值被设置之后立即调用<br>需要注意的是：当为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。</p>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>计算属性提供了一个 <code>getter</code> 和一个可选的 <code>setter</code> 。属性的 <code>getter</code> 和 <code>setter</code> 的关键词是 <code>get</code> 和 <code>set</code> ，在 <code>setter</code> 中新值是 <code>newValue</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> birthYear: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> age : <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">           <span class="keyword">self</span>.age = newValue</span><br><span class="line">           <span class="keyword">self</span>.birthYear = <span class="number">2016</span> - newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只读计算属性</strong></p>
<p>当一个属性只有 <code>getter</code> 而没有 <code>setter</code> 时，那么它就是一个只读计算属性</p>
<h4 id="类对象的实例和访问："><a href="#类对象的实例和访问：" class="headerlink" title="类对象的实例和访问："></a>类对象的实例和访问：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">person.age = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="类的构造和析构"><a href="#类的构造和析构" class="headerlink" title="类的构造和析构"></a>类的构造和析构</h3><p>我们可以给 <code>Person</code> 自定义一个构造函数，构造函数中需要给所有的存储型属性一个赋值或者默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">   <span class="keyword">self</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以用 <code>name</code> 来实例化一个对象： <code>var person = Person(name:&quot;Tom&quot;)</code></p>
<p>如果所有属性都有默认值，我们没有自定义的构造，系统会生成一个默认的构造函数：<code>var person = Person()</code><br>相应的，如果我们自定义了一个构造函数，那么系统便不会为该类生成默认的构造函数。<br>但是，我们可以把自定义的构造函数写到类的扩展(<code>extension</code>)里，而不是类的原始定义里面。</p>
<p>与构造函数对应的是析构函数：<code>deinit</code></p>
<p><strong>指定构造器和便利构造器</strong><br>指定构造器里面会初始化类实例所有的属性，所以为了保证继承的属性也能被初始化，子类的指定构造器都会调用父类的指定构造器，而类的便利构造器总是会调用本类的指定构造器。<br>也就是说：<strong>指定构造器需要向上调用，便利构造器需要横向调用</strong></p>
<p>所以，我们可以把父类的指定构造函数重写成便利构造，却不能重写父类的便利构造。即便<em>重写</em>了父类的便利构造函数，但是由于我们不能直接调用父类的便利构造函数，所以不用给函数以 <code>override</code> 修饰。</p>
<p><strong>必要构造器</strong> 如果某个构造函数被 <code>required</code> 修饰，那么该函数就是必要构造函数，子类继承该类时都必须要实现改构造函数。在子类重写父类的构造函数的时候，也要加 <code>required</code> 来修饰，以确定继承链上子类的子类也遵守。</p>
<p>除了构造和析构函数，类还有实例的私有函数、公共函数和静态函数。</p>
<h3 id="类、函数的访问控制（访问、继承-重载-权限）"><a href="#类、函数的访问控制（访问、继承-重载-权限）" class="headerlink" title="类、函数的访问控制（访问、继承/重载 权限）"></a>类、函数的访问控制（访问、继承/重载 权限）</h3><p><code>Swift</code> 中的访问控制有 <strong>模块</strong> 和 <strong>源文件</strong> 两个概念。用 “import” 导入的就是模块。</p>
<p>对于类而言的修饰词与权限：</p>
<table>
<thead>
<tr>
<th>修饰词</th>
<th>权限</th>
</tr>
</thead>
<tbody><tr>
<td><code>open</code></td>
<td>修饰的类可以随意继承与访问</td>
</tr>
<tr>
<td><code>public</code></td>
<td>修饰的类只能在本模块内被继承，但是可以随便访问</td>
</tr>
<tr>
<td><code>internal</code></td>
<td>默认 - 模块内拥有访问权限</td>
</tr>
<tr>
<td><code>fileprivate</code></td>
<td>是文件外部不能被访问</td>
</tr>
<tr>
<td><code>private</code></td>
<td>是文件内部不能被访问</td>
</tr>
<tr>
<td><code>final</code></td>
<td>是文件内部也不能被继承</td>
</tr>
</tbody></table>
<p>当然了，对于一个 <code>internal</code> 的类，其属性和方法的级别是不会超出类本身的，比如不可能是 <code>public</code> 。</p>
<p>函数也是同样的修饰词和权限，只是类的继承对应函数的重载权限。<br>函数除了以上几个，常用的修饰词还有 <code>static</code> 和 <code>override</code>。</p>
<p><code>static</code>修饰的是类方法。<code>override</code>修饰的是重写父类的方法。</p>
<h2 id="Swift-中的类和结构体"><a href="#Swift-中的类和结构体" class="headerlink" title="Swift 中的类和结构体"></a>Swift 中的类和结构体</h2><p><code>Swift</code> 中的结构体的能力被大大加强，不仅可以拥有属性，还以有方法、构造函数、甚至是扩展和遵守协议。这样的结构体和类有很多相同点：</p>
<ul>
<li>属性：存储数据</li>
<li>方法：提供一些功能</li>
<li>下标：可以使用下标语法</li>
<li>构造器：生成初始化值</li>
<li>扩展：增加功能</li>
<li>协议：提供某种通用功能</li>
</ul>
<p>当然，类和结构体也有很多不同的地方，类还有许多独有的附加功能：</p>
<ul>
<li>继承：一个类可以继承另一个类的特征</li>
<li>类型转换：运行时检查和解释一个类实例的类型</li>
<li>析构器：一个类实例释放任何其所被分配的资源</li>
<li>引用计数：对一个类的多次引用</li>
</ul>
<p><strong>结构体会提供一个默认的构造函数</strong>，这个构造函数是结构体所有的属性分别作为参数来构建：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point:<span class="type">MyPoint</span> = <span class="type">MyPoint</span>(x: <span class="number">1</span>, y: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>结构体和枚举都是值类型</strong>，值类型在赋值（给变量或者常量）和传递（作为参数给一个函数）的时候都会被拷贝，值类型实例的值属性也会被拷贝。<br><code>Swift</code> 中的整型、浮点型、布尔型、字符串、字典、数组都是值类型，底层都是由结构体来实现的。</p>
<p><strong>类是引用类型</strong>，引用类型在赋值和传递的时候，内容并不会被拷贝。因此赋值的实例和被赋值的实例其实是一份内容，内容在内存中也是一份。</p>
<p><strong>值类型和引用类型的区别</strong>在于，值类型在赋值和传递的时候是深拷贝，而引用类型是浅拷贝。<br>深拷贝就是把内存地址中存放的内容也拷贝一份内存中的内容就会有两份；而浅拷贝只是拷贝了内存的地址，内存中的内容还是只有一份。</p>
<p><img src="/images/%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" alt="值和引用类型的区别"></p>
<p>但需要注意的是，在 <code>Swift</code> 中，并不是值类型一旦被赋值和传递的时候就会被拷贝一份，只有当需要的时候，比如被赋值的实例去改变内容的时候才会真正的去拷贝。</p>
<p><strong>那么，我们到底如何选择结构体或者类呢</strong>？如果你只是用来做以下功能是可以选择结构体：</p>
<ul>
<li>只是用来封装一些相关的数据</li>
<li>这些数据被赋值或者传递的时候会被拷贝一份</li>
<li>不需要被继承</li>
</ul>
<p>比如 <code>CGPoint</code>、<code>CGRect</code>、<code>CGSize</code>等都是结构体。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/17/8-dont_abuse_lazy_load/" class="prev">PREV</a><a href="/2016/08/08/6-shadowsocks_vps_gfw/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2022 <a href="http://blog.iosgg.cn">Abin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/m-forks/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-100885072-1",'auto');ga('send','pageview');</script></body></html>