<!DOCTYPE html><html lang="zh-ch"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> @synchronized 的实现方式 · 阿斌的技术博客</title><meta name="description" content="@synchronized 的实现方式 - Abin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.iosgg.cn/atom.xml" title="阿斌的技术博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="阿斌的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/wxiubin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">@synchronized 的实现方式</h1><div class="post-info">Jun 8, 2017</div><div class="post-content"><p><code>@synchronized</code> 可以保证多线程不会同时执行一段代码，做用类似于锁，但比直接使用锁更加方便直观，那么它究竟是如何实现的呢？</p>
<a id="more"></a>

<h3 id="查看-synchronized-的实现"><a href="#查看-synchronized-的实现" class="headerlink" title="查看 @synchronized 的实现"></a>查看 @synchronized 的实现</h3><p>新建文件 <code>main.m</code> ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *token = <span class="string">@""</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span> (token) &#123;</span><br><span class="line">        printf(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在终端打开当前目录查看 C++ 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<p>打开 <code>main.cpp</code> 文件删除顶部不相关的代码只剩 main 方法后：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *token = __null;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> _rethrow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">id</span> _sync_obj = (<span class="keyword">id</span>)token; <span class="comment">// 为防止代码块修改 token 的指向</span></span><br><span class="line">        objc_sync_enter(_sync_obj);</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">struct</span> _SYNC_EXIT &#123;</span><br><span class="line">                _SYNC_EXIT(<span class="keyword">id</span> arg) : sync_exit(arg) &#123;&#125;</span><br><span class="line">                ~_SYNC_EXIT() &#123;objc_sync_exit(sync_exit);&#125; <span class="comment">// 析构时执行 exit 函数</span></span><br><span class="line">                <span class="keyword">id</span> sync_exit;   <span class="comment">// 用来加锁的对象</span></span><br><span class="line">            &#125; _sync_exit(_sync_obj);</span><br><span class="line"></span><br><span class="line">                printf(<span class="string">""</span>); <span class="comment">// 需要保证被同步执行的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        catch (<span class="keyword">id</span> e) &#123;_rethrow = e;&#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> _FIN &#123;</span><br><span class="line">                _FIN(<span class="keyword">id</span> reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">                ~_FIN() &#123; <span class="keyword">if</span> (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">                <span class="keyword">id</span> rethrow;</span><br><span class="line">            &#125; _fin_force_rethow(_rethrow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上可以看到，代码主要的实现是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_sync_enter()</span><br><span class="line"><span class="comment">// code..</span></span><br><span class="line">objc_sync_exit()</span><br></pre></td></tr></table></figure>

<p>方法按照顺序总共做了这么几件事：</p>
<ol>
<li>定义异常值</li>
<li>定义 <code>_sync_obj</code> 指向用来加锁的对象，防止代码修改加锁对象的指向而造成 <code>objc_sync_enter()</code> 和 <code>objc_sync_exit()</code> 的入参不是一个对象</li>
<li>调用 <code>objc_sync_enter()</code></li>
<li>定义一个结构体，传入 <code>_sync_obj</code>，并在析构的时候执行 <code>objc_sync_exit()</code></li>
<li>执行要保证被同步执行的代码</li>
<li>捕获处理异常</li>
</ol>
<p>其中第4、5步是在 <code>try</code> 的作用域，所以当 5 之后就会析构结构体变量并执行<code>objc_sync_exit()</code></p>
<h3 id="objc-sync-enter-和-objc-sync-exit"><a href="#objc-sync-enter-和-objc-sync-exit" class="headerlink" title="objc_sync_enter() 和 objc_sync_exit()"></a>objc_sync_enter() 和 objc_sync_exit()</h3><p>所幸 runtime 是开源的，可以通过源码查看这两个函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>objc_sync_enter</code> 函数的逻辑：</p>
<ol>
<li>判断 token（用来加锁的对象）是否为空</li>
<li>不为空就通过 <code>id2data</code> 函数拿到一个 <code>SyncData</code> 对象，并加锁</li>
<li>为空则调用空实现函数，可以用符号断点来捕获 token 为空的情况</li>
</ol>
<p><code>objc_sync_exit</code> 的逻辑同样很简单：通过 <code>id2data</code> 函数拿到一个 <code>SyncData</code> 对象，并解锁。</p>
<p>看到这里，已经很明确了，对于 <code>@synchronized</code> 的实现是根据 token 来获得一把锁，在代码前后分别指向加锁和释放锁的操作。</p>
<h3 id="SyncData-和锁的维护"><a href="#SyncData-和锁的维护" class="headerlink" title="SyncData 和锁的维护"></a>SyncData 和锁的维护</h3><p>那如何通过 token 获取一把锁呢，换言之 token 和锁是怎么对应起来的呢？或者说它们之间的关系是如何维护的？</p>
<p>这里就要提到 SyncData 这个数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">alignas</span><span class="params">(CacheLineSize)</span> SyncData </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span>  <span class="comment">// 链表中下一个节点</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;   <span class="comment">// token</span></span><br><span class="line">    <span class="keyword">int32_t</span> threadCount;  <span class="comment">// number of THREADS using this block</span></span><br><span class="line">    <span class="keyword">recursive_mutex_t</span> mutex;    <span class="comment">// 递归锁</span></span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure>

<p>SyncData 做为一个链表节点，存储了 token 本身和下一个节点的信息，<code>id2data</code> 函数获取的就是这个节点。</p>
<p><code>id2data</code> 函数的大致逻辑为：</p>
<p><img src="/images/synchronize-id2data.drawio.png" alt="synchronize-id2data.drawio"></p>
<ol>
<li>从 TLS（Thread Local Storage）中获取 SyncData 并返回</li>
<li>如果1没有获取到则从 SyncCache 获取</li>
<li>如果2仍然没有获取则从 StripedMap 获取一个链表，并从链表中查找</li>
<li>如果3没找到，则生成一个 SyncData</li>
<li>把找到或者生成的 SyncData 数据缓存至 TLS 或者 SyncCache</li>
<li>返回 SyncData</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>@synchronized</code> 的本质是根据 token 来获取一把锁，在编译的时候在需要保持同步的代码前后分别插入 <code>objc_sync_enter()</code> 和 <code>objc_sync_exit()</code> 函数。token 和 锁的映射数据是由一个哈希map来存储，key 是 token，value 是映射数据的链表。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/06/10/13-objc-weak/" class="prev">PREV</a><a href="/2017/05/12/11-objc-block/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2022 <a href="http://blog.iosgg.cn">Abin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/m-forks/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-100885072-1",'auto');ga('send','pageview');</script></body></html>