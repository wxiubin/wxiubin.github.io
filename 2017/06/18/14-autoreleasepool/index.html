<!DOCTYPE html><html lang="zh-ch"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> autoreleasepool 是如何实现的 · 阿斌的技术博客</title><meta name="description" content="autoreleasepool 是如何实现的 - Abin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.iosgg.cn/atom.xml" title="阿斌的技术博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="阿斌的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/wxiubin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">autoreleasepool 是如何实现的</h1><div class="post-info">Jun 18, 2017</div><div class="post-content"><p>查看下 <code>@autoreleasepool</code> 的 cpp 代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>查看 <code>__AtAutoreleasePool</code> 的结构，发现是一个结构体，在构造方法中调用了 <code>objc_autoreleasePoolPush()</code>，并在析构中调用了 <code>objc_autoreleasePoolPop()</code>。</p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相当于源码被重写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">	<span class="comment">// code ...</span></span><br><span class="line">	objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AutoreleasePoolPage-的结构"><a href="#AutoreleasePoolPage-的结构" class="headerlink" title="AutoreleasePoolPage 的结构"></a>AutoreleasePoolPage 的结构</h2><p><code>objc_autoreleasePoolPush()</code> 和 <code>objc_autoreleasePoolPop()</code> 内部分别调用的是 <code>AutoreleasePoolPage</code> 的 <code>push()</code> 和 <code>pop()</code> 方法。<code>AutoreleasePoolPage</code> 是 C++ 实现的一个类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;    <span class="comment">// 标识，是否是一个 AutoreleasePoolPage 对象，16 bytes</span></span><br><span class="line">    id *next;               <span class="comment">// 下一个存放对象的地址，8 bytes</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread; <span class="comment">// 所属线程，8 bytes</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent; <span class="comment">// 双向链表的上一个节点，8 bytes</span></span><br><span class="line">    AutoreleasePoolPage *child;         <span class="comment">// 双向链表的下一个节点，8 bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;               <span class="comment">// 链表深度，4 bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;                     <span class="comment">// 4 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIZE-sizeof(*this) bytes of contents follow</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> * p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id * <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="comment">// 当前 page 存放的第一个对象</span></span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id * <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="comment">// 当前 page 存放的最后一个对象</span></span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否是空的 page</span></span><br><span class="line">        <span class="keyword">return</span> next == begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否是满的地址</span></span><br><span class="line">        <span class="keyword">return</span> next == end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lessThanHalfFull</span><span class="params">()</span> </span>&#123; <span class="comment">// 存放对象是否小于容器的一半容量</span></span><br><span class="line">        <span class="keyword">return</span> (next - begin() &lt; (end() - begin()) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> <span class="comment">// 新增一个存放对象</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">        *next++ = obj;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">            AutoreleasePoolPage *page = hotPage();</span><br><span class="line">            <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">                page = page-&gt;parent;</span><br><span class="line">                setHotPage(page);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            id obj = *--page-&gt;next;</span><br><span class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">                objc_release(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setHotPage(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从数据格式上可以看出 <code>AutoreleasePoolPage</code> 具有以下特点：</p>
<ol>
<li>本质上是一个双向链表的节点，其中 <code>parent</code> 和 <code>child</code> 分别为上个节点和下个节点。</li>
<li>重写了 <code>new</code> 运算符，对象会占用 4096 bytes</li>
<li>本身的属性只用了 56 个bytes，剩下的空间用来存放加入自动释放池的对象</li>
</ol>
<p><img src="/images/autoreleasepool.page.png" alt="autoreleasepool.page"></p>
<h2 id="AutoreleasePoolPage-的加入和移除对象"><a href="#AutoreleasePoolPage-的加入和移除对象" class="headerlink" title="AutoreleasePoolPage 的加入和移除对象"></a>AutoreleasePoolPage 的加入和移除对象</h2><p><code>objc_autoreleasePoolPush()</code> 函数最终会调用 <code>autoreleaseFast()</code> 函数，在缓存释放池中插入 <code>POOL_BOUNDARY</code>，这是一个宏，其实是一个 <code>nil</code>。</p>
<p>在 ARC 下调用 <code>autorelease</code> 方法会调用 <code>autoreleaseFast()</code> 函数自动把对象加入自动释放池。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123; <span class="comment">// atautoreleasepoolobj = objc_autoreleasePoolPush();</span></span><br><span class="line">    <span class="keyword">id</span> obj1 = [[[<span class="built_in">NSMutableDictionary</span> alloc] init] autorelease];</span><br><span class="line">    <span class="keyword">id</span> obj2 = [[[<span class="built_in">NSMutableDictionary</span> alloc] init] autorelease];</span><br><span class="line">&#125; <span class="comment">// objc_autoreleasePoolPop(atautoreleasepoolobj);</span></span><br></pre></td></tr></table></figure>

<p>上述代码会依次在链表中加入 <code>POOL_BOUNDARY</code>、<code>obj1</code>、<code>obj2</code>。</p>
<p><img src="/images/autoreleasepool.002.png" alt="autoreleasepool.002"></p>
<p>当 调用 <code>objc_autoreleasePoolPop(atautoreleasepoolobj);</code> 时，就会把地址为 <code>atautoreleasepoolobj</code> 的 <code>POOL_BOUNDARY</code> 之后的所有对象都发送一遍 <code>release</code> 消息。并将 <code>POOL_BOUNDARY</code> 及其之后的对象给移除。</p>
<h3 id="autoreleaseFast-的实现"><a href="#autoreleaseFast-的实现" class="headerlink" title="autoreleaseFast 的实现"></a>autoreleaseFast 的实现</h3><p><code>autoreleaseFast</code> 函数会先获取当前的 AutoreleasePoolPage，当前的 page 被称为 <code>hotPage</code>。</p>
<ol>
<li>获取 hotPage</li>
<li>如果 hotPage 存在，且为用满，则将对象加入当前 page</li>
<li>如果 hotPage 存在，但是满了，则创建下一个节点，将下一个节点设置为 hotPage，并将对象加入 hotPage</li>
<li>如果 hotPage 不存在，则创建一个节点，将该节点设置为 hotPage，并将对象加入 hotPage</li>
</ol>
<h3 id="hotPage-的存取"><a href="#hotPage-的存取" class="headerlink" title="hotPage 的存取"></a>hotPage 的存取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> key 43</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">hotPage</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    <span class="keyword">if</span> ((id *)result == EMPTY_POOL_PLACEHOLDER) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (result) result-&gt;fastcheck();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (page) page-&gt;fastcheck();</span><br><span class="line">    tls_set_direct(key, (<span class="keyword">void</span> *)page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hotPage 是存放在当前线程的私有存储中，所以是线程安全的。</p>
<h2 id="autorelease-和-runloop"><a href="#autorelease-和-runloop" class="headerlink" title="autorelease 和 runloop"></a>autorelease 和 runloop</h2><p>先思考一个问题：<code>AutoreleasePoolPage</code> 的作用是把一个对象加入自动释放池后，在 <code>objc_autoreleasePoolPop</code> 的时候就会自动清理和释放这些对象，而我们的APP一经启动，在运行的这段时间内，是如何进行清理的，即什么时候会调用 <code>objc_autoreleasePoolPop</code> 方法？</p>
<p>答案就是主线程在 runloop 中添加了两个 observe，分别监听了 <code>kCFRunLoopEntry</code> 和 <code>kCFRunLoopBeforeWaiting</code>，来做<br><code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>autoreleasepool</code> 的实现是一个双向链表，当 push 的时候会插入一个 nil 来当做哨兵对象，并把这个哨兵对象的地址返回，之后任何对象调用 <code>autorelease</code> 方法时，都会把对象插入进去。当调用 pop 方法时，入参就是哨兵对象的地址，<code>autoreleasepool</code> 会把入参地址之后的所有对象都挨个发送 <code>release</code> 消息。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/10/10/17-send-week-report-email/" class="prev">PREV</a><a href="/2017/06/10/13-objc-weak/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2022 <a href="http://blog.iosgg.cn">Abin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/m-forks/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-100885072-1",'auto');ga('send','pageview');</script></body></html>