<!DOCTYPE html><html lang="zh-ch"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 不要滥用懒加载 · 阿斌的技术博客</title><meta name="description" content="不要滥用懒加载 - Abin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.iosgg.cn/atom.xml" title="阿斌的技术博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="阿斌的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/wxiubin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">不要滥用懒加载</h1><div class="post-info">Feb 17, 2017</div><div class="post-content"><p>写代码是一种习惯的养成，一种生活的态度。</p>
<p>以前学 iOS 开发的时候，喜欢在 ViewController 和 Cell 里初始化视图，还有数据模型数组的时候，是用的懒加载（Lazy-Load）。为什么这么喜欢用懒加载来实例化一个属性呢？</p>
<ol>
<li>觉得懒加载可以延迟加载，需要的时候才去加载数据；</li>
<li>数组和字典等集合类型还可以防止为初始化或者使用中被置为 <code>nil</code>；</li>
<li>类的属性多了这么写看着更舒服、清晰<br>。。。</li>
</ol>
<a id="more"></a>

<p>基本上每个属性我都希望去懒加载实现它，这会给我一种错觉：这样写更好，性能更高！</p>
<p>其实，这是一个不好的习惯，随着编程时间越发的长，越是觉得之前有些偏激。</p>
<p>iOS 中懒加载的写法一般为重写 <code>getter</code> 方法，判断属性是否为 <code>nil</code> ，是的话去初始化，否就直接返回：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)layerView &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_layerView) &#123;</span><br><span class="line">        _layerView = [<span class="built_in">UIView</span> new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _layerView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是我们有更清晰、简洁的写法</strong></p>
<p>一般来说，如果 <code>layerView</code> 是控制器的属性，我们一般都会在 <code>viewDidLoad</code> 方法中去加载视图；如果是一个视图，我们一般会在 <code>initWithFrame:</code> 加载子视图，我们只需要安安静静的用以下代码来初始化即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_layerView = [<span class="built_in">UIView</span> new];</span><br></pre></td></tr></table></figure>

<p> 根本无需使用懒加载，因为如果你不是一个人在开发的话，你<em>永远不会知道你的队友会在 <code>get</code> 方法里面做什么</em>。</p>
<p> 而且这样写更简洁，更清晰。当属性很多的时候也可以使用以下方式来初始化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.layerView = (&#123;</span><br><span class="line">    [<span class="built_in">UIView</span> new];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>用懒加载至少六行代码，现在只需要一行或者三行就可以做到。</p>
<p><strong>我们不能使用懒加载来防止那些可能出现的错误</strong></p>
<p>很大一部分人用懒加载是为了保证数组和字典等集合类型在使用中永远不会是空值，这是错误的做法，因为可变集合类型被初始化之后，在正确的使用中如果不会被置 <code>nil</code>，那么也无需使用懒加载。如果因此而引发的问题，也可以帮我们提前找到原因。</p>
<p><strong>对于耗时或性能很大的操作，我们可以使用惰性计算而不是懒加载</strong></p>
<p>比如，我重构项目遇到的一个需求：请求股票列表返回的数据会告诉我总共会有上千条数据，并且不做分页，就是全部展示，滑到第几条就去请求第几条的数据。</p>
<p>上千条数据不做分页，我们也不可能全部请求回来，即便能全部请求回来也不可能在一个方法里去做这样的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *dataArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">  [dataArray addObject:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，对于 TableView 来讲，上千条数据，当然需要 Array 的 count 返回是一千。这个时候我们可以用<a href="https://zh.wikipedia.org/zh-hant/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC" target="_blank" rel="noopener">惰性计算</a>来解决这个问题：有多少条数据，我们就让数组返回的 count 是多少，但是只有真正的向数组取这个下标的对象的时候，我们才去处理！</p>
<p>那我们继承 NSArray 来写（真正的写一个 NSArray 还需要重写其他几个方法，在此不细说）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span>(^HTLazyArrayItemBlock)(<span class="built_in">NSInteger</span> index);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTLazyArray</span> : <span class="title">NSArray</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithItemBlock:(HTLazyArrayItemBlock)block count:(<span class="built_in">NSInteger</span>)count;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"HTLazyArray.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTLazyArray</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) HTLazyArrayItemBlock block;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HTLazyArray</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> _ct;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithItemBlock:(HTLazyArrayItemBlock)block count:(<span class="built_in">NSInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _ct = count;</span><br><span class="line">        <span class="keyword">self</span>.block = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - override</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _ct;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.block(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们初始化的时候传入一个 count，被 TableView 的代理方法访问的时候，有则返回数据模型，没有就先返回 <code>nil</code>，待到网络请求到数据再进行刷新。这样做的性能损耗微乎其微。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.lazyArray = [[HTLazyArray alloc]initWithItemBlock:^<span class="keyword">id</span>(<span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">       HTQuoteAHCellModel *model = weakSefl.cache[@(index)];</span><br><span class="line">       <span class="keyword">return</span> model;</span><br><span class="line">   &#125; count:dataTotalCount];</span><br></pre></td></tr></table></figure>

<p><strong>那么，我们到底什么时候该用懒加载呢？</strong></p>
<p>懒加载的使用需要看具体的场景，比如一个很可能不会被使用的属性，使用懒加载确实可以避免无所谓的性能损耗；<br>还有就是 <code>null_resettable</code> 修饰的属性，该属性意为：setter nullable，但是 getter nonnull，典型的就是控制器的 <code>view</code> 属性：“你可以不要我，把我置空；但只要你需要我，我就是在的”。诸如此类都可以使用懒加载。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/03/08/9-weak_ref_array/" class="prev">PREV</a><a href="/2016/10/05/7-swift_basic_grammar/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2022 <a href="http://blog.iosgg.cn">Abin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/m-forks/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-100885072-1",'auto');ga('send','pageview');</script></body></html>