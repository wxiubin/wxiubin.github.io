<!DOCTYPE html><html lang="zh-ch"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 阿斌的技术博客</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.iosgg.cn/atom.xml" title="阿斌的技术博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="阿斌的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/wxiubin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/05/27/20-ios-performance/" class="post-title-link">iOS 性能优化实践</a></h2><div class="post-info">May 27, 2019</div><div class="post-content"><p>随着业务的不断迭代和功能的逐渐增多，或是业务的需要，APP 在体量上来之后或多或少都会遇见性能问题。</p>
<p>笔者所在的直播技术团队就遇见了在很大的直播间里，有着持续的大量的广播发送到客户端，而大量的广播会造成 UI 的更新或者动画的展示造成的性能问题。本篇博客就主要记录了我对所遇到的性能问题的思考和解决办法。</p></div><a href="/2019/05/27/20-ios-performance/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/09/03/19-ios-hybrid/" class="post-title-link">iOS Hybrid 的实践</a></h2><div class="post-info">Sep 3, 2018</div><div class="post-content"><p>iOS Hybrid 相关大致上有以下几块内容：</p>
<ol>
<li>基础能力支持，H5 和 native 的互相通信能力</li>
<li>业务支撑，Bridge 的协议制定</li>
<li>性能优化，hybrid 离线能力建设</li>
<li>数据统计和性能分析以及监控</li>
</ol></div><a href="/2018/09/03/19-ios-hybrid/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/26/18-z1-share-xcodeproj/" class="post-title-link">Xcode 的 project 文件介绍</a></h2><div class="post-info">Mar 26, 2018</div><div class="post-content"><p>对应一个 iOS 项目而言，我们平时都是直接双击 <code>xcodeproj</code> 文件，打开项目进行代码编写，点击运行之后可以编译运行 APP，却很少思考这个文件的本质上是什么？有哪些部分组成，做用都是什么，这篇文章简单介绍下项目文件的组成。</p></div><a href="/2018/03/26/18-z1-share-xcodeproj/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/26/18-iOS-crash/" class="post-title-link">iOS Crash文件的解析</a></h2><div class="post-info">Jan 26, 2018</div><div class="post-content"><blockquote>
<p><a href="https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION" target="_blank" rel="noopener">相关 Apple 官方文档</a></p>
</blockquote>
<p>iOS Crash文件的解析需要三个文件：</p>
<ul>
<li>bilibili.crash/bilibili.ips - 从崩溃的手机、itunes connect或者第三方日志系统获得</li>
<li>bilibili.dSYM - 从 xcarchive 文件里获得</li>
<li>symbolicatecrash 在 xcode 里，不同版本所在位置也不一样</li>
</ul></div><a href="/2018/01/26/18-iOS-crash/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/10/10/17-send-week-report-email/" class="post-title-link">用 Python 写脚本发送工作周报</a></h2><div class="post-info">Oct 10, 2017</div><div class="post-content"><p>事情的起因是这样的，每周都要发送工作周报，标题是需要的固定的格式（方便规则收信），比如 <em>【工作周报】 xxx 11.20-11.24</em>，发送和抄送也是给固定的人，企业邮箱还没有模板，所以每次发邮件都要复制粘贴标题、发送人和抄送人，只有内容是手写，便萌发了用脚本发送邮件的想法。</p></div><a href="/2017/10/10/17-send-week-report-email/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/18/14-autoreleasepool/" class="post-title-link">autoreleasepool 是如何实现的</a></h2><div class="post-info">Jun 18, 2017</div><div class="post-content"><p>查看下 <code>@autoreleasepool</code> 的 cpp 代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>查看 <code>__AtAutoreleasePool</code> 的结构，发现是一个结构体，在构造方法中调用了 <code>objc_autoreleasePoolPush()</code>，并在析构中调用了 <code>objc_autoreleasePoolPop()</code>。</p></div><a href="/2017/06/18/14-autoreleasepool/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/10/13-objc-weak/" class="post-title-link">weak 弱引用的实现方式</a></h2><div class="post-info">Jun 10, 2017</div><div class="post-content"><p>weak 修饰的变量，不会增加所引用对象的引用计数，且会在该对象析构后自动将指向置为nil。其本质是初始化和赋值操作会被编译器改写为 <code>objc_initWeak</code> 或者 <code>objc_storeWeak</code> 函数调用。<code>objc_initWeak</code> 的逻辑只是比 <code>objc_storeWeak</code> 多了所赋值对象的判空，接下来会直接调用 <code>storeWeak(id *location, objc_object *newObj)</code> 函数。</p></div><a href="/2017/06/10/13-objc-weak/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/08/12-objc-synchronized/" class="post-title-link">@synchronized 的实现方式</a></h2><div class="post-info">Jun 8, 2017</div><div class="post-content"><p><code>@synchronized</code> 可以保证多线程不会同时执行一段代码，做用类似于锁，但比直接使用锁更加方便直观，那么它究竟是如何实现的呢？</p></div><a href="/2017/06/08/12-objc-synchronized/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/12/11-objc-block/" class="post-title-link">Objc 中 Block 的实现原理</a></h2><div class="post-info">May 12, 2017</div><div class="post-content"><p>Objc 中的 Block 其实是一个对象，之前也说过 Objc 中对象的结构</p>
<p>来看下 Block 的实现，新建 <code>TooT.m</code> 文件写一个 <code>func_TooT</code> 函数：</p></div><a href="/2017/05/12/11-objc-block/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/10/10-afnnetworking-source-read/" class="post-title-link">AFNetworking 源码阅读</a></h2><div class="post-info">May 10, 2017</div><div class="post-content"><blockquote>
<p>版本：AFNetworking 3.1.0</p>
</blockquote>
<p><em>AFNetworking</em> 主要的几个类或协议：</p>
<ul>
<li><code>AFURLSessionManager</code></li>
<li><code>AFHTTPSessionManager</code></li>
<li><code>AFNetworkReachabilityManager</code></li>
<li><code>AFSecurityPolicy</code></li>
<li><code>&lt;AFURLRequestSerialization&gt;</code></li>
<li><code>&lt;AFURLResponseSerialization&gt;</code></li>
</ul></div><a href="/2017/05/10/10-afnnetworking-source-read/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2022 <a href="http://blog.iosgg.cn">Abin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/m-forks/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-100885072-1",'auto');ga('send','pageview');</script></body></html>