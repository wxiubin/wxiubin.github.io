<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿斌的技术博客</title>
  
  
  <link href="http://blog.iosgg.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.iosgg.cn/"/>
  <updated>2022-06-24T17:43:17.551Z</updated>
  <id>http://blog.iosgg.cn/</id>
  
  <author>
    <name>Abin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 性能优化实践</title>
    <link href="http://blog.iosgg.cn/2019/05/27/20-ios-performance/"/>
    <id>http://blog.iosgg.cn/2019/05/27/20-ios-performance/</id>
    <published>2019-05-27T14:41:39.000Z</published>
    <updated>2022-06-24T17:43:17.551Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务的不断迭代和功能的逐渐增多，或是业务的需要，APP 在体量上来之后或多或少都会遇见性能问题。</p><p>笔者所在的直播技术团队就遇见了在很大的直播间里，有着持续的大量的广播发送到客户端，而大量的广播会造成 UI 的更新或者动画的展示造成的性能问题。本篇博客就主要记录了我对所遇到的性能问题的思考和解决办法。</p><span id="more"></span><h3 id="性能问题的发现和定位"><a href="#性能问题的发现和定位" class="headerlink" title="性能问题的发现和定位"></a>性能问题的发现和定位</h3><p>一般而言，除非是性能比较敏感的页面，我们在开发中是不会去着重的考虑性能问题，但是随着功能的迭代，原本之前简单的页面变的复杂，多出了动画或者比较多的视图层级和特殊效果，逐渐就会变得笨重。除此之外就是本来没有多少问题的页面，在某些场景下就会有很严重的性能问题。</p><p>解决这些问题的第一步就是发现问题。那么，如何做到定位和发现呢？</p><h5 id="卡顿检测工具"><a href="#卡顿检测工具" class="headerlink" title="卡顿检测工具"></a>卡顿检测工具</h5><p>对于卡顿检测工具，一般来说有两种实现方案：</p><ol><li>主线程卡顿监控。在子线程通过判断主线程的runloop状态来确定是否为卡顿</li><li>FPS 监控。原理是计算屏幕刷新的两次间隔，过大时判断为卡顿。</li></ol><p>两种方案抖动都比较大，但都具备参考意义，同时可以分析其他参数比如 CPU 和 内存的占用来判断是否是真正的卡顿。</p><h5 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h5><p>卡顿检测工具只能发现常规的性能问题，但是对当只有特殊场景下才会出现的问题就无能为力了。这个情况就需要人为的模拟这些特殊场景。</p><p>直播 APP 的业务上有个特点：用户送的道具动画要足够酷炫（毕竟是花了钱的）；用户发送的弹幕要尽可能的展示，因为这是核心体验。这两个功能在很大的直播间下性能问题会被放大，因为平时开发中很少会遇见<em><strong>大量且持续</strong></em>的道具和弹幕。</p><p>压力测试可以模拟线上一些大活动或者直播间的场景，造成海量弹幕和道具动画，这个时候去分析和检测，可以很轻易的发现各种平时隐藏的小问题。</p><h5 id="Instruments-分析工具"><a href="#Instruments-分析工具" class="headerlink" title="Instruments 分析工具"></a>Instruments 分析工具</h5><p>上面两个主要讲的是如何发现问题，那么当发现问题之后就需要去定位这些问题，才能再进行解决。</p><p>利用官方提供的性能分析工具，Leaks 和 Allocations 可以分析内存相关的问题；Core Animation 分析 UI 相关的问题；最常用的就是 Time Profiler，用来分析CPU 占用和方法耗时来定位卡顿问题。网上相关的资料也比较多，这里就不展开来说了。</p><h3 id="问题的治理和优化方案"><a href="#问题的治理和优化方案" class="headerlink" title="问题的治理和优化方案"></a>问题的治理和优化方案</h3><p><a href="https://github.com/ibireme/">ibireme</a> 在 <a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a> 一文中也有提及 CPU 和 GPU 分别的资源消耗和解决方案。基本上性能问题的治理就是避免大的资源消耗；空间换取时间；让 CPU 和 GPU 做自己擅长的事情。</p><p>先简单说下我实现的方案，对于弹幕这个性能大户，我采用了基于 CoreText 排版技术来计算图文混排中的各种尺寸和位置，然后在异步绘制这些文字和图片，最后生成一张位图在主线程去显示。详细可见 demo <a href="https://github.com/wxiubin/WDText">WDText</a>，基本上参考借鉴了 YYText 和 AsyncDisplayKit 的思路。所实现的排版和渲染框架的核心思想只有一个：对于一条弹幕UI，尽可能的将内容放到后台线程去排版绘制，所有非文字UI都抽象成 Attachment，扩展了 <code>DrawAble</code> 能力之后便支持在后台去绘制。这样可以减少主线程的耗时之外也可以大量的减少视图层级。</p><h5 id="减少视图层级-amp-amp-手动计算-frame"><a href="#减少视图层级-amp-amp-手动计算-frame" class="headerlink" title="减少视图层级 &amp;&amp; 手动计算 frame"></a>减少视图层级 &amp;&amp; 手动计算 frame</h5><p>Time Profiler 中发现 masonry 的方法耗时极高，最后定位到了 cell 上的控件居然是使用的自动布局，究其原因是早期业务使用自动布局也并没有性能问题，随后慢慢的迭代为了保持统一也是继续使用了自动布局技术。</p><p>cell 中有多个 image view 组成一个弹幕背景，也有用户的等级、头衔和身份等信息视图，这些 background images 预先在后台线程预先合成一个 image，这样对应的 background image view 也可以减少到一个。</p><p>手动计算 frame是一个很简单但是在长期的业务迭代中会积少成多的一个问题，而且当视图足够复杂时，用手动计算frame来替代 autolayout 也是一个很繁琐的任务。不过好在，我在尽可能的减少了视图层级之后，需要计算的 UI 控件由十数个减少到了三个，也算是意外之喜了。</p><h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>这块所做的工作主要是业务接收到广播之后，在后台线程去转换数据，使用 CoreText 去预排版，计算该弹幕所占的位置和大小。同时计算富文本弹幕中的图片位置。并把这些数据存放在 cell view model 中，也变相的缓存了 cell 的高度。</p><h5 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h5><p>弹幕中的用户等级信息之类的信息有着不规则路径和背景填充，之前的实现方案是磨切圆角和 draw 来实现。分析发现性能问题之后，直接放入后台去预先绘制成一个 image 再显示，至于如何在后台绘制显示一张图片，后面会提到。</p><h5 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h5><p>为了更好利用多核多线程的优势，把繁重的渲染任务扔到后台线程去执行，绘制为一张位图之后设置给 layer 的 contents 属性，大体逻辑如下，真实场景会增加一些条件判断：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)_display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>([<span class="keyword">self</span> _queue], ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="comment">// 开始绘制</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.contents = (__bridge <span class="type">id</span>)(image.CGImage);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="减少线程数量"><a href="#减少线程数量" class="headerlink" title="减少线程数量"></a>减少线程数量</h5><p>性能问题治理完之后，压测的表现情况并不乐观，查看日志有较多的如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Event:           wakeups</span><br><span class="line">Wakeups:         45003 wakeups over the last 240 seconds (188 wakeups per second average), exceeding limit of 150 wakeups per second over 300 seconds</span><br><span class="line">Action taken:    none</span><br><span class="line">Duration:        239.91s</span><br><span class="line">Steps:           0</span><br></pre></td></tr></table></figure><p>最后恍然大悟，发现是线程过多导致。原因就是 Socket 数据的解析，序列化，以及到各个业务层的分发全是使用 GCD 来分发，参考了 <a href="https://developer.apple.com/videos/play/wwdc2017/706/">WWDC-Modernizing Grand Central Dispatch Usage</a> 的优化指南之后通过设置 target queue 来限制了线程的并发。</p><h5 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h5><blockquote><p>没有什么问题是降级解决不了的，如果有，那就再降一次</p></blockquote><p>降级是一个见效很快，但也是最后不得已而为之的手段。对于高频次的性能问题可以通过在线配置限制速率来实现降级，具体到直播业务中就是限制广播的分发速率。对于动画等性能大户可以是动画效果降级使用低配版本的资源。</p><p>这些都可以快速的解决问题，但是是以降低用户体验为手段来实现的，是不到最后基本不会采用的方案。</p><h3 id="优化结果确认"><a href="#优化结果确认" class="headerlink" title="优化结果确认"></a>优化结果确认</h3><p>性能问题不能一拍头脑想当然的来优化，优化之后也需要确认是否有效果。FPS 是否提升了？提升的同时 Memory 和 CPU 的占用是否也跟着提升了，提升了多少？是否可接受？这些都需要在考量之中。我们就需要分析优化前后的几个重要指标来衡量。一般而言有三个基础指标：FPS、Memory 和 CPU usage。我简单的实现了一个小工具，来分析和导出这三个指标数据，详细见 demo <a href="https://github.com/wxiubin/GGWatcher">GGWatcher</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优化的主要工作点：</p><ul><li>性能问题定位和分析</li><li>缓存视图位置和尺寸，cell 的高度</li><li>减少视图层级</li><li>autolayout 改为手动计算 frame</li><li>多张图片预先合成一张</li><li>实现排版框架支持后台线程异步排版和渲染</li><li>限制线程并发</li><li>优化效果确认</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着业务的不断迭代和功能的逐渐增多，或是业务的需要，APP 在体量上来之后或多或少都会遇见性能问题。&lt;/p&gt;
&lt;p&gt;笔者所在的直播技术团队就遇见了在很大的直播间里，有着持续的大量的广播发送到客户端，而大量的广播会造成 UI 的更新或者动画的展示造成的性能问题。本篇博客就主要记录了我对所遇到的性能问题的思考和解决办法。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="性能优化" scheme="http://blog.iosgg.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS Hybrid 的实践</title>
    <link href="http://blog.iosgg.cn/2018/09/03/19-ios-hybrid/"/>
    <id>http://blog.iosgg.cn/2018/09/03/19-ios-hybrid/</id>
    <published>2018-09-03T10:47:53.000Z</published>
    <updated>2022-06-24T17:09:19.689Z</updated>
    
    <content type="html"><![CDATA[<p>iOS Hybrid 相关大致上有以下几块内容：</p><ol><li>基础能力支持，H5 和 native 的互相通信能力</li><li>业务支撑，Bridge 的协议制定</li><li>性能优化，hybrid 离线能力建设</li><li>数据统计和性能分析以及监控</li></ol><a id="more"></a><h2 id="一、JavaScript-和-Native-的相互通信"><a href="#一、JavaScript-和-Native-的相互通信" class="headerlink" title="一、JavaScript 和 Native 的相互通信"></a>一、JavaScript 和 Native 的相互通信</h2><h3 id="JS-调用-Native"><a href="#JS-调用-Native" class="headerlink" title="JS 调用 Native"></a>JS 调用 Native</h3><p>业内比较好的通用做法是上下文注入，安卓 <code>addJavascriptInterface</code> 注入。iOS 使用 <code>WKWebView - scriptMessageHandler</code> 注入，这种方式注入其实只给注入对象起了一个名字<code>nativeObject</code>，这种对象只有一个函数 <code>postMessage</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;准备要传给native的数据，包括指令，数据，回调等</span><br><span class="line">var data &#x3D; &#123;</span><br><span class="line">    method:&#39;location&#39;,</span><br><span class="line">    data:&#39;http:&#x2F;&#x2F;baidu.com&#39;,</span><br><span class="line">    callback:&#39;1&#39;,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;传递给客户端</span><br><span class="line">window.webkit.messageHandlers.nativeObject.postMessage(data);</span><br></pre></td></tr></table></figure><p>客户端接收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    NSDictionary *msgBody &#x3D; message.body;</span><br><span class="line">    NSString *method &#x3D; msgBody[@&quot;method&quot;];</span><br><span class="line">    NSString *data &#x3D; msgBody[@&quot;data&quot;];</span><br><span class="line">    &#x2F;&#x2F; perform method with data</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有 1. 请求拦截，2. 弹窗拦截两种方式。</p><p><strong>请求拦截</strong> 也可以实现 JS call Native，这是唯一一个在 iOS 上可以从 iOS 6 及以前版本支持的方案，也是唯一一个支持 Android WebView，iOS UI/WK WebView 的方案；但是这个方案有丢消息和消息长度的限制。</p><p>著名开源框架 <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a> 使用的就是这种通信方案。</p><h3 id="Native-调用-JS"><a href="#Native-调用-JS" class="headerlink" title="Native 调用 JS"></a>Native 调用 JS</h3><p>使用 <code>evaluatingJavaScript</code> 执行JS代码</p><p>JS 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function calljs(data)&#123;</span><br><span class="line">    console.log(JSON.parse(data)) </span><br><span class="line">    &#x2F;&#x2F;1 识别客户端传来的数据</span><br><span class="line">    &#x2F;&#x2F;2 对数据进行分析，从而调用或执行其他逻辑  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>户端此时要调用需要在 OBJC 拼接字符串，拼出一个 JS 代码，传递的数据用 JSON</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;不展开了,data是一个字典，把字典序列化</span><br><span class="line">NSString *paramsString &#x3D; [self _serializeMessageData:data];</span><br><span class="line">NSString* javascriptCommand &#x3D; [NSString stringWithFormat:@&quot;calljs(&#39;%@&#39;);&quot;, paramsString];</span><br><span class="line">&#x2F;&#x2F;要求必须在主线程执行JS</span><br><span class="line">[self.webView evaluateJavaScript:javascriptCommand completionHandler:nil];</span><br></pre></td></tr></table></figure><h2 id="二、Bridge-的协议制定"><a href="#二、Bridge-的协议制定" class="headerlink" title="二、Bridge 的协议制定"></a>二、Bridge 的协议制定</h2><p>Bridge 的参数必须遵守设置规则，否则每个方法都在开发时随意设置，以后就不好统一管理。</p><p>比如参数最外层可以有5个：</p><ol><li>method，定位到具体是哪个方法</li><li>data，所有的业务参数</li><li>callbackId，native接收到时给 H5 的响应</li><li>successId，动作成功给 H5 的响应</li><li>failedId，动作失败给 H5 的响应，如网络请求失败</li></ol><p>那么一个正常的参数看起来是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"location"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"url"</span>:<span class="string">"http://baidu.com"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"callbackId"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successId"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"failedId"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着业务的迭代，Bridge 方法会越来越多，如果 <code>method</code> 只使用一层结构的话，native 把所有的方法都放到一个类里，这个类就会越来越大，不易于维护；如果每个方法都是一个类的话，类似功能的方法之间则不能统一管理，过于离散。可以加个域的概念，比如按功能来划分，在 <code>method</code> 加入代表着功能的 <strong>域</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"location.forward"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"url"</span>:<span class="string">"http://baidu.com"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"callbackId"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successId"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"failedId"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"location.close"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">"callbackId"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successId"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"failedId"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是随着业务的快速增长，膨胀的 APP 会划分几个业务模块，某个模块想新增 Bridge 的话，就有可能冲掉之前已有的 Bridge，比如已经存在了 <code>&quot;location.forward&quot;</code> 方法，这个时候，便可以再增加一层，对于 <code>&quot;method&quot;</code> 的约定就是：<code>模块 + 功能 + 具体的方法</code>，</p><p>比如电商模块想要打开某个页面，方法就是 <code>&quot;mall.location.forward&quot;</code>。当然，对于所有业务模块都需要使用的基础能力，是要放入基础Bridge中而非每个模块都自己实现一套。</p><h2 id="三、离线能力建设"><a href="#三、离线能力建设" class="headerlink" title="三、离线能力建设"></a>三、离线能力建设</h2><p>到了上面的那一步，基本上可以完成大部分的活动或者需求中的功能了。但是如果想用户体验更好，使用 H5 页得到近似于原生的页面时，就要想办法加快页面的加载速度，在转场动画期间尽可能减少 H5 页面白屏的时间。</p><p>比较优雅的方法就是提前把 H5 打包下载到本地，然后使用 <code>NSURLProtocol</code> 拦截请求把本地资源替换线上资源。但是这种方案有个问题，需要使用私有 API，具有一定的风险。使用私有 API 进行拦截，还有另外一个问题，就是 POST 请求会丢失 body，所以尽量只拦截 GET 请求。</p><p>到了 iOS 11 就可以使用系统提供的 <code>[setURLSchemeHandler:forURLScheme:]</code> 实现离线。<br>但 <code>WKURLSchemeHandler</code> 不能处理 Http、Https 等常规 scheme，所以需要自定义 scheme。</p><p>基本方案就是，在 WebView loadRequest 前判断本地是否有离线资源，支持离线且有离线资源的时候，修改 Http/Https 为自定义的 scheme，然后在 <code>NSURLProtocol</code> 或者 <code>WKURLSchemeHandler</code>去实现对本地资源的加载。</p><h2 id="四、数据统计和监控建设"><a href="#四、数据统计和监控建设" class="headerlink" title="四、数据统计和监控建设"></a>四、数据统计和监控建设</h2><p>doing。。</p><p>参考：<a href="http://www.awhisper.net/2018/03/06/hybrid-webcontainer/" target="_blank" rel="noopener">从零收拾一个hybrid框架</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS Hybrid 相关大致上有以下几块内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础能力支持，H5 和 native 的互相通信能力&lt;/li&gt;
&lt;li&gt;业务支撑，Bridge 的协议制定&lt;/li&gt;
&lt;li&gt;性能优化，hybrid 离线能力建设&lt;/li&gt;
&lt;li&gt;数据统计和性能分析以及监控&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="Hybrid" scheme="http://blog.iosgg.cn/tags/Hybrid/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 的 project 文件介绍</title>
    <link href="http://blog.iosgg.cn/2018/03/26/18-z1-share-xcodeproj/"/>
    <id>http://blog.iosgg.cn/2018/03/26/18-z1-share-xcodeproj/</id>
    <published>2018-03-26T13:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.689Z</updated>
    
    <content type="html"><![CDATA[<p>对应一个 iOS 项目而言，我们平时都是直接双击 <code>xcodeproj</code> 文件，打开项目进行代码编写，点击运行之后可以编译运行 APP，却很少思考这个文件的本质上是什么？有哪些部分组成，做用都是什么，这篇文章简单介绍下项目文件的组成。</p><a id="more"></a><p>下面的三个段落不是按顺序看的。。</p><h2 id="一、项目内容由哪些部分组成"><a href="#一、项目内容由哪些部分组成" class="headerlink" title="一、项目内容由哪些部分组成"></a>一、项目内容由哪些部分组成</h2><p><img src="/images/16187673847932.jpg" alt=""></p><ul><li>Source Files<ul><li>源文件：h/m 文件等</li><li>资源文件：图片、JSON、settings 等</li><li>Infos：plist 配置文件，App 展示的配置信息或者 App 行为的一些配置<ul><li>App 信息</li><li>能力声明</li><li>默认配置</li></ul></li></ul></li><li>Targets</li><li>Schemes</li><li>Build Phases：设置一个项目编译的顺序步骤<ul><li>Target Dependencies</li><li>Compile Sources</li><li>Link with Libraries</li><li>Run Script</li></ul></li><li>Build Settings：项目的编译参数<ul><li>Compiler</li><li>Linker</li><li>Assets</li><li>Packaging</li></ul></li></ul><h3 id="Infos"><a href="#Infos" class="headerlink" title="Infos"></a>Infos</h3><p>Info.plist 用于向提供关于 App，或者framework的一些重要信息。它指定了比如一个应用的名称、版本号，启动方式，获取的权限，以及 Schema 的定义。</p><p>代码中可以使用以下代码拿到 info 信息：<code>[[NSBundle mainBundle] infoDictionary]</code><br><img src="/images/16187679564355.jpg" alt=""></p><p>比如在 URL types 里定义一个 scheme 为 <code>demonow</code>，那么在其他 APP 或着 Safari 里使用 <code>demonow://</code> 便可以打开这个 APP。</p><h3 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h3><p>定义了构建的过程和步骤，在 Xcode 中，这些步骤可以随意拖动调整顺序。<br>除了 Dependencies 不能挪动，不能删除，只能是第一个被执行的。</p><p>自定义编译前运行的脚本，比如使用 CocoaPods 进行依赖管理的项目里，会有一项 <code>[CP] Check Pods Manifest.lock</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff "$&#123;PODS_PODFILE_DIR_PATH&#125;/Podfile.lock" "$&#123;PODS_ROOT&#125;/Manifest.lock" &gt; /dev/null</span><br><span class="line">if [ $? != 0 ] ; then</span><br><span class="line">    # print error to STDERR</span><br><span class="line">    echo "error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation." &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> This output is used by Xcode <span class="string">'outputs'</span> to avoid re-running this script phase.</span></span><br><span class="line">echo "SUCCESS" &gt; "$&#123;SCRIPT_OUTPUT_FILE_0&#125;"</span><br></pre></td></tr></table></figure><p>每次 build 前都会执行这个脚本去对 <code>Podfile.lock</code> 和 <code>Pods/Manifest.lock</code> 文件进行比对，如果依赖库的版本不一样，就会编译失败，提示执行 <code>pod install</code>，来确保配置文件的版本号和本地库的版本号一致。</p><p><img src="/images/build_phases_pod_script.png" alt="build_phases_pod_script"><br><img src="/images/pod_lock_error.png" alt="pod_lock_error"></p><h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>在 build settings 中，可以配置每个任务的详细内容。build 过程的每一个阶段，都有许多选项：从编译、链接一直到 code signing 和 packaging。<br>具体的含义和设置项可以到<a href="https://xcodebuildsettings.com/" target="_blank" rel="noopener">xcodebuildsettings</a>查看。</p><h3 id="Build-rules"><a href="#Build-rules" class="headerlink" title="Build rules"></a>Build rules</h3><p>Build rules 指定了不同的文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定类型的文件添加处理方法，那么可以在此处添加一条新的规则。一条 build rule 指定了其应用于哪种类型文件，该类型文件是如何被处理的，以及输出的内容该如何处置。</p><h2 id="二、一些实体的概念"><a href="#二、一些实体的概念" class="headerlink" title="二、一些实体的概念"></a>二、一些实体的概念</h2><p>Scheme、Target、Project 和 Workspace</p><p>下文中的 product 是一个编译产物：可能是一个 APP，也可能是一个静态库或者动态库。</p><p><img src="/images/16188041644544.jpg" alt=""></p><h3 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h3><p>Workspace，在 Xcode 4之前，当时大多数工作流程仅限于单个 project，，一个 project 也可以引用一个或者多个其他的 project，但是这样其他的 project 不能相互引用和依赖；从 Xcode 4开始提供了 Workspace 可以管理多个 project，提供多个 project 和 target 之间的依赖关系。</p><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>Xcode project 是构建一个或者多个 product 所需的源文件、资源和配置的集合，是管理资源的容器，本身是无法被编译的。包含用于 build product 的所有元素，并且维护这些资源之间的关系。project 可以独立存在，也可以被包含在一个 Workspace 中。<br>一个 project 包含一个或者多个 target，一个 target 编译时引用的资源是它所在 project 所有管理资源的子集。project 给所有的 target 定义了默认的 build settings，target 也可以自定义相关设置来覆盖默认的 build settings。</p><p>project 主要由以下几部分组成：</p><ol><li>引用的源文件<ol><li>代码的头文件和实现文件</li><li>资源文件（文本、xml 等）</li><li>图片资源</li><li>界面资源文件（xib、storyboard）</li></ol></li><li>在文件结构的导航中，采用 group 来组织文件</li><li>project 级别的编译配置（build configurations），比如 debug release 配置</li><li>targets，给 target 提供默认的 build settings</li><li>运行或者调试的可执行环境：命令参数和环境变量，如 debug</li></ol><h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p>一个 target 对应一个 product，target 继承 project 的 build settings，target 级别的 build settings 会覆盖 project 级别的 build settings。<br>同一时间只有个一个 active target，就是当前 Scheme 指定的，它定义了这个 product 怎样被 build 的所有细节。</p><p>target 常用来构建一个 APP 的不同版本，比如企业版、用户版等，Today 等扩展也是用 target 来管理的。</p><h3 id="scheme"><a href="#scheme" class="headerlink" title="scheme"></a>scheme</h3><p>针对一个指定的 target，scheme 定义了 build 这个 target 时使用的 configuration，执行的任务，环境参数等等。Scheme 可以理解为一个工作流，Xcode 中预设了六个工作流：Build, Run, Test, Profile, Analyze, Archive。</p><p>一个 scheme 对应一个 target，同一个 target 可以有多个 scheme，通过灵活地配置 scheme，我们可以方便地管理不同环境下 App 的测试，调试，打包流程。</p><h2 id="三、xcodeproj-的本质"><a href="#三、xcodeproj-的本质" class="headerlink" title="三、xcodeproj 的本质"></a>三、xcodeproj 的本质</h2><p>工程文件的本质是什么？我们平时开发中很少会去看这个文件内部是如何组织的，基本上只有这个文件在合并代码时冲突了才会点进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── demo</span><br><span class="line">│   ├── AppDelegate.h</span><br><span class="line">│   ├── AppDelegate.m</span><br><span class="line">│   ├── Assets.xcassets</span><br><span class="line">│   ├── 。。。</span><br><span class="line">└── demo.xcodeproj</span><br><span class="line">    ├── project.pbxproj</span><br><span class="line">    ├── project.xcworkspace</span><br><span class="line">    └── xcuserdata</span><br></pre></td></tr></table></figure><p><code>xcodeproj</code> 文件本质上是一个文件夹。它里面的 <code>project.pbxproj</code> 文件存储着 Xcode 工程的各项配置参数，本质上是一种旧风格的 Property List 文件，历史可追溯到 NeXT 的 OpenStep。其可读性不如 XML 和 JSON，为了方便阅读和理解，这个文件里有大量的注释。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#x2F;&#x2F; 字典</span><br><span class="line">isa &#x3D; XCBuildConfiguration; &#x2F;&#x2F; 对象的类型</span><br><span class="line">buildSettings &#x3D; &#123;</span><br><span class="line">LD_RUNPATH_SEARCH_PATHS &#x3D; ( &#x2F;&#x2F; 数组</span><br><span class="line">&quot;$(inherited)&quot;,</span><br><span class="line">&quot;@executable_path&#x2F;Frameworks&quot;,</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>project.pbxproj</code> 文件里数据层级的最外层是 <code>rootObject</code>，然后其次 objects 里面是平铺存放的各种对象，相同的类型放到一起，被称之为一个 section，section 是比较虚的概念，本身没有类型，只是一段注释。</p><p>一些常见的类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PBXBuildFile                &#x2F;&#x2F; 所有可编译的文件，比如源码、资源文件、nib 文件等</span><br><span class="line">PBXBuildPhase               &#x2F;&#x2F; Build Phases 里定义的步骤，如拷贝资源、运行自定义脚本</span><br><span class="line">PBXHeadersBuildPhase        &#x2F;&#x2F; public header</span><br><span class="line">PBXResourcesBuildPhase      &#x2F;&#x2F; Assets storyboard</span><br><span class="line">PBXShellScriptBuildPhase    &#x2F;&#x2F; [CP] Check Pods Manifest.lock</span><br><span class="line">PBXSourcesBuildPhase        &#x2F;&#x2F; Build Phases - Compile Source</span><br><span class="line">PBXFileReference            &#x2F;&#x2F; 项目文件导航区里的所有文件都是这个类型</span><br><span class="line">PBXGroup                    &#x2F;&#x2F; 项目文件导航区里的黄色「文件夹」样式的 group</span><br><span class="line">PBXNativeTarget             &#x2F;&#x2F; 项目里的 target</span><br><span class="line">PBXProject                  &#x2F;&#x2F; 项目的定义</span><br><span class="line">XCBuildConfiguration        &#x2F;&#x2F; 项目或者 target 的 configuration</span><br></pre></td></tr></table></figure><p><strong>PBXProject</strong> 项目的一些定义，主要属性是targets，描述了这个项目下有哪些 target<br><strong>PBXNativeTarget</strong> 项目中的 target，定义了有哪些 <code>buildConfigurationList</code> 和 <code>buildPhases</code><br><strong>PBXBuildFile</strong></p><p>在 Build Phases 里出现的可编译资源都是这个类型，比如依赖的一个库，或者代码源文件，再或者一些图片资源，StoryBoard xib 等资源。</p><h2 id="四、点击-run-按钮后都发生了什么"><a href="#四、点击-run-按钮后都发生了什么" class="headerlink" title="四、点击 run 按钮后都发生了什么"></a>四、点击 run 按钮后都发生了什么</h2><p><img src="/images/build_log.png" alt="build_log"></p><p>可以看到上面先 build 的是一些静态库，或者依赖的 target，最后再 build 当前 Scheme 对应的 target。把整个 build 日志导出来看，编译每个 target 开始前都会打印是编译哪个  project 的 target，并且使用的是哪个 configuration：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Build target demo of project demo with configuration Inhouse</span><br></pre></td></tr></table></figure><p>编译过程：</p><ul><li>编译依赖的的库和 target</li><li>写入辅助文件：hmap、script 等</li><li>执行预设脚本，如 CocoaPod 编译前脚本，checkPods Manifest.lock</li><li>编译文件：针对每一个文件进行编译，生成可执行文件 Mach-O</li><li>链接文件：将项目中的多个可执行文件合并成一个文件</li><li>资源的编译、优化、导入（Asset、nib 等）</li><li>配置文件生成（info.plist里有写参数是动态配置的)</li><li>签名、打包</li></ul><p>TODO：待补全源码编译的过程：预编译-词法分析-语义分析-巴拉巴拉</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/library/archive/featuredarticles/XcodeConcepts/Concept-Projects.html" target="_blank" rel="noopener">Xcode Concepts - Apple Developer Documentation</a></li><li><a href="https://objccn.io/issue-6-1/" target="_blank" rel="noopener">https://objccn.io/issue-6-1/-Build 过程</a></li><li><a href="https://nshipster.com/xcconfig/" target="_blank" rel="noopener">https://nshipster.com/xcconfig/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对应一个 iOS 项目而言，我们平时都是直接双击 &lt;code&gt;xcodeproj&lt;/code&gt; 文件，打开项目进行代码编写，点击运行之后可以编译运行 APP，却很少思考这个文件的本质上是什么？有哪些部分组成，做用都是什么，这篇文章简单介绍下项目文件的组成。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS Crash文件的解析</title>
    <link href="http://blog.iosgg.cn/2018/01/26/18-iOS-crash/"/>
    <id>http://blog.iosgg.cn/2018/01/26/18-iOS-crash/</id>
    <published>2018-01-26T13:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.689Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION" target="_blank" rel="noopener">相关 Apple 官方文档</a></p></blockquote><p>iOS Crash文件的解析需要三个文件：</p><ul><li>bilibili.crash/bilibili.ips - 从崩溃的手机、itunes connect或者第三方日志系统获得</li><li>bilibili.dSYM - 从 xcarchive 文件里获得</li><li>symbolicatecrash 在 xcode 里，不同版本所在位置也不一样</li></ul><a id="more"></a><h3 id="解析步骤"><a href="#解析步骤" class="headerlink" title="解析步骤"></a>解析步骤</h3><p>1.新建一个文件夹，将上面四个文件放进去，使用以下命令查找 symbolicatecrash 文件的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;Applications&#x2F;Xcode.app -name symbolicatecrash -type f</span><br></pre></td></tr></table></figure><p>2.使用以下命令确定和 bilibili.dSYM 文件里的 UUID 一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid bilibili.dSYM</span><br></pre></td></tr></table></figure><p>3.使用该命令解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;symbolicatecrash bilibili.crash bilibili.dSYM &gt; crash.log</span><br></pre></td></tr></table></figure><p>如果遇到无法找到DEVELOPER_DIR的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DEVELOPER_DIR&#x3D;&#39;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#39;</span><br></pre></td></tr></table></figure><p>打开新生成的 crash.log 文件，搜索关键词 Exception 查看崩溃信息，从 <code>Termination Reason: Namespace SPRINGBOARD, Code 0x8badf00d</code> 中的 code 可以确定大致原因。</p><h3 id="Exception-Type"><a href="#Exception-Type" class="headerlink" title="Exception Type"></a>Exception Type</h3><ul><li>EXC_BAD_ACCESS</li></ul><p>此类型的Excpetion是我们最长碰到的Crash，通常用于访问了不改访问的内存导致。一般EXC_BAD_ACCESS后面的”()”还会带有补充信息。</p><pre><code>* SIGSEGV: 通常由于重复释放对象导致，这种类型在切换了ARC以后应该已经很少见到了。* SIGABRT:  收到Abort信号退出，通常Foundation库中的容器为了保护状态正常会做一些检测，例如插入nil到数组中等会遇到此类错误。* SEGV:（Segmentation  Violation），代表无效内存地址，比如空指针，未初始化指针，栈溢出等；* SIGBUS：总线错误，与 SIGSEGV 不同的是，SIGSEGV 访问的是无效地址，而 SIGBUS 访问的是有效地址，但总线访问异常(如地址对齐问题)* SIGILL：尝试执行非法的指令，可能不被识别或者没有权限</code></pre><ul><li>EXC_BAD_INSTRUCTION</li></ul><p>此类异常通常由于线程执行非法指令导致</p><ul><li>EXC_ARITHMETIC</li></ul><p>除零错误会抛出此类异常</p><h3 id="Exception-Code"><a href="#Exception-Code" class="headerlink" title="Exception Code"></a>Exception Code</h3><ul><li>0xbaaaaaad 此种类型的log意味着该Crash log并非一个真正的Crash，它仅仅只是包含了整个系统某一时刻的运行状态。通常可以通过同时按Home键和音量键，可能由于用户不小心触发</li><li>0xbad22222当VOIP程序在后台太过频繁的激活时，系统可能会终止此类程序</li><li>0x8badf00d 程序启动或者恢复时间过长被watch dog终止</li><li>0xc00010ff 程序执行大量耗费CPU和GPU的运算，导致设备过热，触发系统过热保护被系统终止</li><li>0xdead10cc 程序退到后台时还占用系统资源，如通讯录被系统终止</li><li>0xdeadfa11 程序无响应用户强制关闭</li></ul><h3 id="脚本自动解析"><a href="#脚本自动解析" class="headerlink" title="脚本自动解析"></a>脚本自动解析</h3><p>2019 年更新…</p><p>如果每次都手动输入命令，也太繁琐了些，写个脚本自动解析，还能支持批量解。后缀改成 <code>command</code> 还能双击打开。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line">function export_()</span><br><span class="line">&#123;</span><br><span class="line">cd $1</span><br><span class="line">export DEVELOPER_DIR="/Applications/XCode.app/Contents/Developer"</span><br><span class="line">if [[ ! -d outlog ]]; then</span><br><span class="line">mkdir outlog</span><br><span class="line">else </span><br><span class="line">echo "outlog exist"</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function analyze()</span><br><span class="line">&#123;</span><br><span class="line">for crash_file in $(find . -name "*.ips" -o -name "*.crash"); do</span><br><span class="line">        new_file=$(basename $crash_file)</span><br><span class="line"><span class="meta">$</span><span class="bash">1 <span class="variable">$crash_file</span> <span class="variable">$2</span> &gt; outlog/<span class="variable">$new_file</span>+<span class="string">".txt"</span></span></span><br><span class="line">done</span><br><span class="line">echo "done"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [[ $#  &gt; 0 ]]; then</span><br><span class="line">echo </span><br><span class="line">else </span><br><span class="line">set $(pwd)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export_ $1</span><br><span class="line">analyze $(find /Applications/Xcode.app -name symbolicatecrash -type f | tail -1) ./bili-universal_arm64</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;相关 Apple 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;iOS Crash文件的解析需要三个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bilibili.crash/bilibili.ips - 从崩溃的手机、itunes connect或者第三方日志系统获得&lt;/li&gt;
&lt;li&gt;bilibili.dSYM - 从 xcarchive 文件里获得&lt;/li&gt;
&lt;li&gt;symbolicatecrash 在 xcode 里，不同版本所在位置也不一样&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="工具" scheme="http://blog.iosgg.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>用 Python 写脚本发送工作周报</title>
    <link href="http://blog.iosgg.cn/2017/10/10/17-send-week-report-email/"/>
    <id>http://blog.iosgg.cn/2017/10/10/17-send-week-report-email/</id>
    <published>2017-10-10T11:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>事情的起因是这样的，每周都要发送工作周报，标题是需要的固定的格式（方便规则收信），比如 <em>【工作周报】 xxx 11.20-11.24</em>，发送和抄送也是给固定的人，企业邮箱还没有模板，所以每次发邮件都要复制粘贴标题、发送人和抄送人，只有内容是手写，便萌发了用脚本发送邮件的想法。</p><a id="more"></a><p>用脚本只需要第一次使用的时候配置收件人、抄送人和标题的格式，之后就只需要：</p><ol><li>双击脚本文件</li><li>输入时间，如 11.20-11.24</li><li>输入周报内容</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 配置项</span><br><span class="line">from_addr &#x3D; &#39;wangxiubin@bbbbbbbb.com&#39; # 发送方邮箱</span><br><span class="line">password &#x3D; &#39;passMhr22i6Uword&#39; # 发送方邮箱的密码（企业邮箱-设置-客户端专用密码）</span><br><span class="line">to_addr &#x3D; &#39;abcdefg@bbbbbbbb.com&#39; # 收件人邮箱</span><br><span class="line">cc_addr &#x3D; &#39;abcdrfghij@bbbbbbbb.com&#39;# 抄送人邮箱</span><br><span class="line"></span><br><span class="line">from_name&#x3D; &#39;王修斌&#39;# 发件人姓名</span><br><span class="line"></span><br><span class="line"># QQ 企业邮箱不用修改</span><br><span class="line">smtp_addr &#x3D; &#39;smtp.exmail.qq.com&#39;</span><br><span class="line">smtp_port &#x3D; 465</span><br></pre></td></tr></table></figure><h3 id="构建邮件"><a href="#构建邮件" class="headerlink" title="构建邮件"></a>构建邮件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def _build_msg(content,date):</span><br><span class="line">msg &#x3D; MIMEText(content, &#39;plain&#39;, &#39;utf-8&#39;)</span><br><span class="line">msg[&#39;From&#39;] &#x3D; _format_addr(&#39;%s &lt;%s&gt;&#39; % (from_name, from_addr) )</span><br><span class="line">msg[&#39;To&#39;] &#x3D; _format_addr( &#39;zhuyue &lt;%s&gt;&#39; % to_addr )</span><br><span class="line">msg[&#39;CC&#39;] &#x3D; _format_addr( &#39;bplus-ios &lt;%s&gt;&#39; % cc_addr )</span><br><span class="line">msg[&#39;Subject&#39;] &#x3D; Header(&#39;【B+iOS周报】 %s %s&#39; % (from_name, date), &#39;utf-8&#39;).encode()</span><br><span class="line">return msg</span><br></pre></td></tr></table></figure><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def send_email(msg):</span><br><span class="line">print</span><br><span class="line">try:</span><br><span class="line">print &#39;初始化 SMTP...&#39;</span><br><span class="line">server &#x3D; smtplib.SMTP_SSL(smtp_addr, smtp_port)</span><br><span class="line">print &#39;初始化 SMTP 成功&#39;</span><br><span class="line"># server.set_debuglevel(1)</span><br><span class="line">print &#39;开始登陆邮箱服务...&#39;</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">print &#39;开始发送邮件...&#39;</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">print &#39;邮件发送成功！&#39;</span><br><span class="line">except server.SMTPException,e:</span><br><span class="line">    print &#39;邮件发送失败 %s&#39; % e</span><br><span class="line">finally:</span><br><span class="line">    server.quit()</span><br></pre></td></tr></table></figure><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def sendEmailCommand():</span><br><span class="line"></span><br><span class="line">input_date &#x3D; app.dateInput.get()</span><br><span class="line">msg_content &#x3D; app.content.get(&quot;0.0&quot;, &quot;end&quot;)</span><br><span class="line">send_email(_build_msg(msg_content, input_date))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Application(Frame):</span><br><span class="line">    def __init__(self, master&#x3D;None):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line">        self.createWidgets()</span><br><span class="line"></span><br><span class="line">    def createWidgets(self):</span><br><span class="line">    self.header &#x3D; Frame()</span><br><span class="line">        self.dateLabel &#x3D; Label(self.header, text&#x3D;&#39;周报标题日期(如 11.20-11.24)：&#39;)</span><br><span class="line">        self.dateLabel.grid(row&#x3D;0,column&#x3D;0)</span><br><span class="line">        self.dateInput &#x3D; Entry(self.header)</span><br><span class="line">        self.dateInput.grid(row&#x3D;0,column&#x3D;1)</span><br><span class="line">        self.sendButton &#x3D; Button(self.header, text&#x3D;&#39;发送&#39;, command&#x3D;sendEmailCommand)</span><br><span class="line">        self.sendButton.grid(row&#x3D;0,column&#x3D;2)</span><br><span class="line">        self.content &#x3D; Text(self,padx&#x3D;10)</span><br><span class="line">        self.content.insert(END, &#39;本周任务：\n\n下周任务：\n\n风险评估：\n&#39;)</span><br><span class="line">        self.content.pack()</span><br><span class="line">    self.header.pack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app &#x3D; Application()</span><br><span class="line"># 设置窗口标题:</span><br><span class="line">app.master.title(&#39;发送周报邮件&#39;)</span><br><span class="line"># 主消息循环:</span><br><span class="line">app.mainloop()</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 脚本目录</span><br><span class="line">python GUI.py</span><br></pre></td></tr></table></figure><p>或者修改名称 <code>GUI.command</code> 方便双击打开。<br>执行时提示权限不足可在终端执行 <code>chmod +x GUI.command</code></p><h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p><img src="/images/2017-10-10-send-week-report-email.png" alt="效果预览"></p><p>终端输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化 SMTP...</span><br><span class="line">初始化 SMTP 成功</span><br><span class="line">开始登陆邮箱服务...</span><br><span class="line">开始发送邮件...</span><br><span class="line">邮件发送成功！</span><br></pre></td></tr></table></figure><p>最终只需要在脚本的图形界面中输入时间段和内容，然后点击发送，美滋滋~ 以后再也不用 <code>command+C</code> 、<code>command+V</code> 了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;事情的起因是这样的，每周都要发送工作周报，标题是需要的固定的格式（方便规则收信），比如 &lt;em&gt;【工作周报】 xxx 11.20-11.24&lt;/em&gt;，发送和抄送也是给固定的人，企业邮箱还没有模板，所以每次发邮件都要复制粘贴标题、发送人和抄送人，只有内容是手写，便萌发了用脚本发送邮件的想法。&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://blog.iosgg.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="http://blog.iosgg.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>autoreleasepool 是如何实现的</title>
    <link href="http://blog.iosgg.cn/2017/06/18/14-autoreleasepool/"/>
    <id>http://blog.iosgg.cn/2017/06/18/14-autoreleasepool/</id>
    <published>2017-06-18T11:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>查看下 <code>@autoreleasepool</code> 的 cpp 代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <code>__AtAutoreleasePool</code> 的结构，发现是一个结构体，在构造方法中调用了 <code>objc_autoreleasePoolPush()</code>，并在析构中调用了 <code>objc_autoreleasePoolPop()</code>。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相当于源码被重写为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line"><span class="comment">// code ...</span></span><br><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AutoreleasePoolPage-的结构"><a href="#AutoreleasePoolPage-的结构" class="headerlink" title="AutoreleasePoolPage 的结构"></a>AutoreleasePoolPage 的结构</h2><p><code>objc_autoreleasePoolPush()</code> 和 <code>objc_autoreleasePoolPop()</code> 内部分别调用的是 <code>AutoreleasePoolPage</code> 的 <code>push()</code> 和 <code>pop()</code> 方法。<code>AutoreleasePoolPage</code> 是 C++ 实现的一个类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;    <span class="comment">// 标识，是否是一个 AutoreleasePoolPage 对象，16 bytes</span></span><br><span class="line">    id *next;               <span class="comment">// 下一个存放对象的地址，8 bytes</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread; <span class="comment">// 所属线程，8 bytes</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent; <span class="comment">// 双向链表的上一个节点，8 bytes</span></span><br><span class="line">    AutoreleasePoolPage *child;         <span class="comment">// 双向链表的下一个节点，8 bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;               <span class="comment">// 链表深度，4 bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;                     <span class="comment">// 4 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIZE-sizeof(*this) bytes of contents follow</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> * p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id * <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="comment">// 当前 page 存放的第一个对象</span></span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id * <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="comment">// 当前 page 存放的最后一个对象</span></span><br><span class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否是空的 page</span></span><br><span class="line">        <span class="keyword">return</span> next == begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否是满的地址</span></span><br><span class="line">        <span class="keyword">return</span> next == end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lessThanHalfFull</span><span class="params">()</span> </span>&#123; <span class="comment">// 存放对象是否小于容器的一半容量</span></span><br><span class="line">        <span class="keyword">return</span> (next - begin() &lt; (end() - begin()) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> <span class="comment">// 新增一个存放对象</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">        *next++ = obj;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">            AutoreleasePoolPage *page = hotPage();</span><br><span class="line">            <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">                page = page-&gt;parent;</span><br><span class="line">                setHotPage(page);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            id obj = *--page-&gt;next;</span><br><span class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">                objc_release(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setHotPage(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据格式上可以看出 <code>AutoreleasePoolPage</code> 具有以下特点：</p><ol><li>本质上是一个双向链表的节点，其中 <code>parent</code> 和 <code>child</code> 分别为上个节点和下个节点。</li><li>重写了 <code>new</code> 运算符，对象会占用 4096 bytes</li><li>本身的属性只用了 56 个bytes，剩下的空间用来存放加入自动释放池的对象</li></ol><p><img src="/images/autoreleasepool.page.png" alt="autoreleasepool.page"></p><h2 id="AutoreleasePoolPage-的加入和移除对象"><a href="#AutoreleasePoolPage-的加入和移除对象" class="headerlink" title="AutoreleasePoolPage 的加入和移除对象"></a>AutoreleasePoolPage 的加入和移除对象</h2><p><code>objc_autoreleasePoolPush()</code> 函数最终会调用 <code>autoreleaseFast()</code> 函数，在缓存释放池中插入 <code>POOL_BOUNDARY</code>，这是一个宏，其实是一个 <code>nil</code>。</p><p>在 ARC 下调用 <code>autorelease</code> 方法会调用 <code>autoreleaseFast()</code> 函数自动把对象加入自动释放池。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123; <span class="comment">// atautoreleasepoolobj = objc_autoreleasePoolPush();</span></span><br><span class="line">    <span class="keyword">id</span> obj1 = [[[<span class="built_in">NSMutableDictionary</span> alloc] init] autorelease];</span><br><span class="line">    <span class="keyword">id</span> obj2 = [[[<span class="built_in">NSMutableDictionary</span> alloc] init] autorelease];</span><br><span class="line">&#125; <span class="comment">// objc_autoreleasePoolPop(atautoreleasepoolobj);</span></span><br></pre></td></tr></table></figure><p>上述代码会依次在链表中加入 <code>POOL_BOUNDARY</code>、<code>obj1</code>、<code>obj2</code>。</p><p><img src="/images/autoreleasepool.002.png" alt="autoreleasepool.002"></p><p>当 调用 <code>objc_autoreleasePoolPop(atautoreleasepoolobj);</code> 时，就会把地址为 <code>atautoreleasepoolobj</code> 的 <code>POOL_BOUNDARY</code> 之后的所有对象都发送一遍 <code>release</code> 消息。并将 <code>POOL_BOUNDARY</code> 及其之后的对象给移除。</p><h3 id="autoreleaseFast-的实现"><a href="#autoreleaseFast-的实现" class="headerlink" title="autoreleaseFast 的实现"></a>autoreleaseFast 的实现</h3><p><code>autoreleaseFast</code> 函数会先获取当前的 AutoreleasePoolPage，当前的 page 被称为 <code>hotPage</code>。</p><ol><li>获取 hotPage</li><li>如果 hotPage 存在，且为用满，则将对象加入当前 page</li><li>如果 hotPage 存在，但是满了，则创建下一个节点，将下一个节点设置为 hotPage，并将对象加入 hotPage</li><li>如果 hotPage 不存在，则创建一个节点，将该节点设置为 hotPage，并将对象加入 hotPage</li></ol><h3 id="hotPage-的存取"><a href="#hotPage-的存取" class="headerlink" title="hotPage 的存取"></a>hotPage 的存取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> key 43</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">hotPage</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    <span class="keyword">if</span> ((id *)result == EMPTY_POOL_PLACEHOLDER) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (result) result-&gt;fastcheck();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (page) page-&gt;fastcheck();</span><br><span class="line">    tls_set_direct(key, (<span class="keyword">void</span> *)page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hotPage 是存放在当前线程的私有存储中，所以是线程安全的。</p><h2 id="autorelease-和-runloop"><a href="#autorelease-和-runloop" class="headerlink" title="autorelease 和 runloop"></a>autorelease 和 runloop</h2><p>先思考一个问题：<code>AutoreleasePoolPage</code> 的作用是把一个对象加入自动释放池后，在 <code>objc_autoreleasePoolPop</code> 的时候就会自动清理和释放这些对象，而我们的APP一经启动，在运行的这段时间内，是如何进行清理的，即什么时候会调用 <code>objc_autoreleasePoolPop</code> 方法？</p><p>答案就是主线程在 runloop 中添加了两个 observe，分别监听了 <code>kCFRunLoopEntry</code> 和 <code>kCFRunLoopBeforeWaiting</code>，来做<br><code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>autoreleasepool</code> 的实现是一个双向链表，当 push 的时候会插入一个 nil 来当做哨兵对象，并把这个哨兵对象的地址返回，之后任何对象调用 <code>autorelease</code> 方法时，都会把对象插入进去。当调用 pop 方法时，入参就是哨兵对象的地址，<code>autoreleasepool</code> 会把入参地址之后的所有对象都挨个发送 <code>release</code> 消息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;查看下 &lt;code&gt;@autoreleasepool&lt;/code&gt; 的 cpp 代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* @autoreleasepool */&lt;/span&gt; &amp;#123; __AtAutoreleasePool __autoreleasepool; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    code ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;p&gt;查看 &lt;code&gt;__AtAutoreleasePool&lt;/code&gt; 的结构，发现是一个结构体，在构造方法中调用了 &lt;code&gt;objc_autoreleasePoolPush()&lt;/code&gt;，并在析构中调用了 &lt;code&gt;objc_autoreleasePoolPop()&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>weak 弱引用的实现方式</title>
    <link href="http://blog.iosgg.cn/2017/06/10/13-objc-weak/"/>
    <id>http://blog.iosgg.cn/2017/06/10/13-objc-weak/</id>
    <published>2017-06-10T11:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>weak 修饰的变量，不会增加所引用对象的引用计数，且会在该对象析构后自动将指向置为nil。其本质是初始化和赋值操作会被编译器改写为 <code>objc_initWeak</code> 或者 <code>objc_storeWeak</code> 函数调用。<code>objc_initWeak</code> 的逻辑只是比 <code>objc_storeWeak</code> 多了所赋值对象的判空，接下来会直接调用 <code>storeWeak(id *location, objc_object *newObj)</code> 函数。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> id </span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将旧的值从链表中清除</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="comment">// 将新的值加入链表</span></span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在refcount表中设置弱引用位，标记该对象被指针弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">    <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <code>storeWeak</code> 函数源码，如果weak指针已经有值，则会清除旧值，然后赋新值。清除旧值和赋值操作分别为 <code>weak_unregister_no_lock</code> 和 <code>weak_register_no_lock</code> 两个函数。</p><p>那入参和 <code>SideTable</code> 又是什么？</p><p>之前再看 <code>@synchronized</code> 的相关实现时，就已经发现 <code>StripedMap</code> 是个哈希表，而这里有一个全局的 <code>StripedMap</code>，key 是一个对象，value 就是 <code>SideTable</code>。<code>SideTable</code> 及其属性的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;    <span class="comment">// 引用计数表，isa 指针存放引用计数不下时，存放在这里</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;<span class="comment">// weak 指针表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;</span><br><span class="line">    <span class="keyword">size_t</span>    num_entries;</span><br><span class="line">    <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span> *referrers; <span class="comment">// 数组</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        mask;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// WEAK_INLINE_COUNT 4</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 对象包装类型</span></span><br><span class="line"><span class="keyword">typedef</span> DisguisedPtr&lt;objc_object *&gt; <span class="keyword">weak_referrer_t</span>;</span><br></pre></td></tr></table></figure><p><code>SideTable</code> 是对 <code>weak_table_t</code> 的封装，除了持有 <code>weak_table_t</code> 变量，还持有一个自旋锁来保证线程安全。</p><p><strong>总结</strong></p><p>内存中维护着一个全局的哈希表，以对象的引用为 key，value 是一个<code>SideTable</code>，<code>SideTable</code> 有一个自旋锁，有存放引用计数，还有一个存放着 weak 修饰的指针地址数组。</p><p>对于 <code>TaggedPointer</code> 对象，并不会设置 isa 中的弱引用标记位</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;weak 修饰的变量，不会增加所引用对象的引用计数，且会在该对象析构后自动将指向置为nil。其本质是初始化和赋值操作会被编译器改写为 &lt;code&gt;objc_initWeak&lt;/code&gt; 或者 &lt;code&gt;objc_storeWeak&lt;/code&gt; 函数调用。&lt;code&gt;objc_initWeak&lt;/code&gt; 的逻辑只是比 &lt;code&gt;objc_storeWeak&lt;/code&gt; 多了所赋值对象的判空，接下来会直接调用 &lt;code&gt;storeWeak(id *location, objc_object *newObj)&lt;/code&gt; 函数。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>@synchronized 的实现方式</title>
    <link href="http://blog.iosgg.cn/2017/06/08/12-objc-synchronized/"/>
    <id>http://blog.iosgg.cn/2017/06/08/12-objc-synchronized/</id>
    <published>2017-06-08T11:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p><code>@synchronized</code> 可以保证多线程不会同时执行一段代码，做用类似于锁，但比直接使用锁更加方便直观，那么它究竟是如何实现的呢？</p><a id="more"></a><h3 id="查看-synchronized-的实现"><a href="#查看-synchronized-的实现" class="headerlink" title="查看 @synchronized 的实现"></a>查看 @synchronized 的实现</h3><p>新建文件 <code>main.m</code> ：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *token = <span class="string">@""</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span> (token) &#123;</span><br><span class="line">        printf(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端打开当前目录查看 C++ 实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>打开 <code>main.cpp</code> 文件删除顶部不相关的代码只剩 main 方法后：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *token = __null;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> _rethrow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">id</span> _sync_obj = (<span class="keyword">id</span>)token; <span class="comment">// 为防止代码块修改 token 的指向</span></span><br><span class="line">        objc_sync_enter(_sync_obj);</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">struct</span> _SYNC_EXIT &#123;</span><br><span class="line">                _SYNC_EXIT(<span class="keyword">id</span> arg) : sync_exit(arg) &#123;&#125;</span><br><span class="line">                ~_SYNC_EXIT() &#123;objc_sync_exit(sync_exit);&#125; <span class="comment">// 析构时执行 exit 函数</span></span><br><span class="line">                <span class="keyword">id</span> sync_exit;   <span class="comment">// 用来加锁的对象</span></span><br><span class="line">            &#125; _sync_exit(_sync_obj);</span><br><span class="line"></span><br><span class="line">                printf(<span class="string">""</span>); <span class="comment">// 需要保证被同步执行的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        catch (<span class="keyword">id</span> e) &#123;_rethrow = e;&#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> _FIN &#123;</span><br><span class="line">                _FIN(<span class="keyword">id</span> reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">                ~_FIN() &#123; <span class="keyword">if</span> (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">                <span class="keyword">id</span> rethrow;</span><br><span class="line">            &#125; _fin_force_rethow(_rethrow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上可以看到，代码主要的实现是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_sync_enter()</span><br><span class="line"><span class="comment">// code..</span></span><br><span class="line">objc_sync_exit()</span><br></pre></td></tr></table></figure><p>方法按照顺序总共做了这么几件事：</p><ol><li>定义异常值</li><li>定义 <code>_sync_obj</code> 指向用来加锁的对象，防止代码修改加锁对象的指向而造成 <code>objc_sync_enter()</code> 和 <code>objc_sync_exit()</code> 的入参不是一个对象</li><li>调用 <code>objc_sync_enter()</code></li><li>定义一个结构体，传入 <code>_sync_obj</code>，并在析构的时候执行 <code>objc_sync_exit()</code></li><li>执行要保证被同步执行的代码</li><li>捕获处理异常</li></ol><p>其中第4、5步是在 <code>try</code> 的作用域，所以当 5 之后就会析构结构体变量并执行<code>objc_sync_exit()</code></p><h3 id="objc-sync-enter-和-objc-sync-exit"><a href="#objc-sync-enter-和-objc-sync-exit" class="headerlink" title="objc_sync_enter() 和 objc_sync_exit()"></a>objc_sync_enter() 和 objc_sync_exit()</h3><p>所幸 runtime 是开源的，可以通过源码查看这两个函数的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>objc_sync_enter</code> 函数的逻辑：</p><ol><li>判断 token（用来加锁的对象）是否为空</li><li>不为空就通过 <code>id2data</code> 函数拿到一个 <code>SyncData</code> 对象，并加锁</li><li>为空则调用空实现函数，可以用符号断点来捕获 token 为空的情况</li></ol><p><code>objc_sync_exit</code> 的逻辑同样很简单：通过 <code>id2data</code> 函数拿到一个 <code>SyncData</code> 对象，并解锁。</p><p>看到这里，已经很明确了，对于 <code>@synchronized</code> 的实现是根据 token 来获得一把锁，在代码前后分别指向加锁和释放锁的操作。</p><h3 id="SyncData-和锁的维护"><a href="#SyncData-和锁的维护" class="headerlink" title="SyncData 和锁的维护"></a>SyncData 和锁的维护</h3><p>那如何通过 token 获取一把锁呢，换言之 token 和锁是怎么对应起来的呢？或者说它们之间的关系是如何维护的？</p><p>这里就要提到 SyncData 这个数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">alignas</span><span class="params">(CacheLineSize)</span> SyncData </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span>  <span class="comment">// 链表中下一个节点</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;   <span class="comment">// token</span></span><br><span class="line">    <span class="keyword">int32_t</span> threadCount;  <span class="comment">// number of THREADS using this block</span></span><br><span class="line">    <span class="keyword">recursive_mutex_t</span> mutex;    <span class="comment">// 递归锁</span></span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure><p>SyncData 做为一个链表节点，存储了 token 本身和下一个节点的信息，<code>id2data</code> 函数获取的就是这个节点。</p><p><code>id2data</code> 函数的大致逻辑为：</p><p><img src="/images/synchronize-id2data.drawio.png" alt="synchronize-id2data.drawio"></p><ol><li>从 TLS（Thread Local Storage）中获取 SyncData 并返回</li><li>如果1没有获取到则从 SyncCache 获取</li><li>如果2仍然没有获取则从 StripedMap 获取一个链表，并从链表中查找</li><li>如果3没找到，则生成一个 SyncData</li><li>把找到或者生成的 SyncData 数据缓存至 TLS 或者 SyncCache</li><li>返回 SyncData</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>@synchronized</code> 的本质是根据 token 来获取一把锁，在编译的时候在需要保持同步的代码前后分别插入 <code>objc_sync_enter()</code> 和 <code>objc_sync_exit()</code> 函数。token 和 锁的映射数据是由一个哈希map来存储，key 是 token，value 是映射数据的链表。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;@synchronized&lt;/code&gt; 可以保证多线程不会同时执行一段代码，做用类似于锁，但比直接使用锁更加方便直观，那么它究竟是如何实现的呢？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Objc 中 Block 的实现原理</title>
    <link href="http://blog.iosgg.cn/2017/05/12/11-objc-block/"/>
    <id>http://blog.iosgg.cn/2017/05/12/11-objc-block/</id>
    <published>2017-05-12T11:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>Objc 中的 Block 其实是一个对象，之前也说过 Objc 中对象的结构</p><p>来看下 Block 的实现，新建 <code>TooT.m</code> 文件写一个 <code>func_TooT</code> 函数：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_TooT</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tt_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> (^bt)(<span class="keyword">void</span>);</span><br><span class="line">    bt = ^()&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,tt_value);</span><br><span class="line">    &#125;;</span><br><span class="line">    bt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在终端中执行 <code>clang -rewrite-objc TooT.m</code> 查看 C++ 的实现。</p><p>打开 <code>TooT.cpp</code> 文件，直接搜索 <code>func_TooT</code>，得到以上代码的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">func_TooT_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">func_TooT_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> tt_value;</span><br><span class="line">  __func_TooT_block_impl_0(<span class="keyword">void</span> *fp, struct __func_TooT_block_desc_0 *desc, <span class="keyword">int</span> _tt_value, <span class="keyword">int</span> flags=<span class="number">0</span>) : tt_value(_tt_value) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __func_TooT_block_func_0(struct __func_TooT_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> tt_value = __cself-&gt;tt_value; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,tt_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">func_TooT_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __func_TooT_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __func_TooT_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_TooT</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tt_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> (*bt)(<span class="keyword">void</span>);</span><br><span class="line">    bt = ((<span class="keyword">void</span> (*)())&amp;__func_TooT_block_impl_0((<span class="keyword">void</span> *)__func_TooT_block_func_0, &amp;__func_TooT_block_desc_0_DATA, tt_value));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)bt)-&gt;FuncPtr)((__block_impl *)bt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上内容其实是四部分：</p><ol><li>该 Block 的结构（数据）</li><li>该 Block 的执行的动作</li><li>该 Block 的信息，比如所占空间大小</li><li><code>func_TooT</code> 函数</li></ol><h4 id="Block-的结构"><a href="#Block-的结构" class="headerlink" title="Block 的结构"></a>Block 的结构</h4><p>从中可以看到 Block 被编译器重写为以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">func_TooT_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">func_TooT_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> tt_value;</span><br><span class="line">  __func_TooT_block_impl_0(<span class="keyword">void</span> *fp, struct __func_TooT_block_desc_0 *desc, <span class="keyword">int</span> _tt_value, <span class="keyword">int</span> flags=<span class="number">0</span>) : tt_value(_tt_value) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不难看出，一个完整的 Block 有以下 6 部分：</p><ol><li>isa：指向类型地址，实现对象的功能</li><li>Flags：</li><li>Reserved：保留变量</li><li>FuncPtr：Block 要执行的动作函数地址</li><li>Desc：Block 的描述信息</li><li>Variables：Block 引用外部的同名同类型变量，在内部拷贝了一份；可能有多个</li></ol><h4 id="Block-的动作"><a href="#Block-的动作" class="headerlink" title="Block 的动作"></a>Block 的动作</h4><p>Block 要执行的动作保存在 <code>__func_TooT_block_func_0</code> 函数中，Block 自身会保存该函数的地址，执行的时候将 Block 自身作为参数传进来，类似于 Objc 中对象的方法默认第一个参数就是对象本身 <code>self</code>。<br>在 Block 中取出被 Block 捕获拷贝的变量，执行在 Block 定义的行为。</p><h4 id="Block-的描述"><a href="#Block-的描述" class="headerlink" title="Block 的描述"></a>Block 的描述</h4><p>只有两个字段： <code>reserved</code>、<code>Block_size</code>，保留字段和 Block 的size</p><h4 id="Block-的初始化"><a href="#Block-的初始化" class="headerlink" title="Block 的初始化"></a>Block 的初始化</h4><p>第四部分就是 <code>void func_TooT(void)</code> ，Block 被初始化去掉类型强转可以被简化为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bt = &amp;__func_TooT_block_impl_0(__func_TooT_block_func_0, &amp;__func_TooT_block_desc_0_DATA, tt_value));</span><br></pre></td></tr></table></figure><p>其中三个参数分别为 Block 动作函数地址，附加信息 和 所捕获的变量。<br>其中 动作函数地址 就是上面所说 Block 要执行的代码，附加信息默认是 {0, sizeof(struct block)}，所捕获的变量在这里只是一个，如果捕获多个时就会有多个参数。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Block 也是一个对象，除了有指向自身类型的 isa 指针，本身还有一个函数指针指向自身要执行动作的函数地址，该函数以 Block 本身为参数，Block 本身还会存储一份引用外部变量的同名同类型的变量（可能为多个），这样才执行的时候可以获取到所引用变量的值。</p><h4 id="block-的实现原理"><a href="#block-的实现原理" class="headerlink" title="__block 的实现原理"></a>__block 的实现原理</h4><p>上面说过 Block 捕获变量是以形参的形式传进一个函数被 Block 本身所持有，这也是在 Objc 中值类型只能被 Block 捕获读取，却不能修改，但是给变量加上 <code>__block</code> 修饰符就可以，看下编译器是怎么实现的，来段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_TooT</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __block <span class="keyword">int</span> tt_value = <span class="number">1021</span>;</span><br><span class="line">    <span class="keyword">void</span> (^bt)(<span class="keyword">void</span>);</span><br><span class="line">    bt = ^()&#123;</span><br><span class="line">        tt_value++;</span><br><span class="line">    &#125;;</span><br><span class="line">    bt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>clang -rewrite-objc TooT.m</code> 看 C++ 代码发现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_tt_value_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_tt_value_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> tt_value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __func_TooT_block_func_0(struct __func_TooT_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_tt_value_0 *tt_value = __cself-&gt;tt_value; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        (tt_value-&gt;__forwarding-&gt;tt_value)++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_TooT</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_tt_value_0 tt_value = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_tt_value_0 *)&amp;tt_value, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_tt_value_0), <span class="number">1021</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*bt)(<span class="keyword">void</span>);</span><br><span class="line">    bt = ((<span class="keyword">void</span> (*)())&amp;__func_TooT_block_impl_0((<span class="keyword">void</span> *)__func_TooT_block_func_0, &amp;__func_TooT_block_desc_0_DATA, (__Block_byref_tt_value_0 *)&amp;tt_value, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)bt)-&gt;FuncPtr)((__block_impl *)bt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到， 相对于上面的代码，只多了 <code>__block</code> 修饰词，<code>int</code> 类型就被编译器重写为一个结构体，结构体中的属性中有一个 <code>__forwarding</code> 指针，还有一个同名同类型变量。</p><p>看初始化结构体的时候把自身地址赋值给 <code>__forwarding</code>，这样即便结构体被当做形参传给 Block，Block 也是可以通过结构体的  <code>__forwarding</code> 指针指向的结构体的同名同类型变量取到真正的变量，只能说这个思路实现的真好~</p><p>Block 的动作函数中我们也可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt_value++; 被重写为：</span></span><br><span class="line">(tt_value-&gt;__forwarding-&gt;tt_value)++;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Objc 中的 Block 其实是一个对象，之前也说过 Objc 中对象的结构&lt;/p&gt;
&lt;p&gt;来看下 Block 的实现，新建 &lt;code&gt;TooT.m&lt;/code&gt; 文件写一个 &lt;code&gt;func_TooT&lt;/code&gt; 函数：&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="Objc" scheme="http://blog.iosgg.cn/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking 源码阅读</title>
    <link href="http://blog.iosgg.cn/2017/05/10/10-afnnetworking-source-read/"/>
    <id>http://blog.iosgg.cn/2017/05/10/10-afnnetworking-source-read/</id>
    <published>2017-05-10T11:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>版本：AFNetworking 3.1.0</p></blockquote><p><em>AFNetworking</em> 主要的几个类或协议：</p><ul><li><code>AFURLSessionManager</code></li><li><code>AFHTTPSessionManager</code></li><li><code>AFNetworkReachabilityManager</code></li><li><code>AFSecurityPolicy</code></li><li><code>&lt;AFURLRequestSerialization&gt;</code></li><li><code>&lt;AFURLResponseSerialization&gt;</code></li></ul><a id="more"></a><p><img src="/images/AFNetworking.001.png" alt="AFNetworking.001"></p><h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><p><code>AFHTTPSessionManager</code> 是我们使用 <em>AFNetworking</em> 框架最外层或者是可以直接使用的类，它对于框架核心类 <code>AFURLSessionManager</code> 进行了常用的封装。比如设置 <em>BaseURL</em> 和请求序列化，<code>AFHTTPSessionManager</code> 重要的两个属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURL</span> *baseURL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer</span><br></pre></td></tr></table></figure><p>当发送一个 GET 请求时，框架会依次调用以下三个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[AFHTTPSessionManager GET:parameters:progress:success:failure:]`</span><br><span class="line">[AFHTTPSessionManager dataTaskWithHTTPMethod:URLString:parameters:uploadProgress:downloadProgress:success:failure:]`</span><br><span class="line">[AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</span><br></pre></td></tr></table></figure><p>第一个方法是 <code>AFHTTPSessionManager</code> 对 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code> 等请求做的一个封装，它们的区别就是请求方法的不同，不同的请求会传入不同的参数给第二个方法，在第二个方法中会对传入的参数进行序列化。具体的序列化方法可以查看 <code>AFHTTPRequestSerializer</code>。然后会把序列化之后的 <code>NSMutableURLRequest</code> 作为参数调用第三方方法，这时就进入了框架的核心类： <code>AFURLSessionManager</code>。</p><h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><p><code>AFURLSessionManager</code> 持有一个 <code>NSURLSession</code> 类型的 <code>session</code> 属性，并作为该属性的 <code>delegate</code>，遵守实现了 <code>NSURLSessionDelegate</code>, <code>NSURLSessionTaskDelegate</code>, <code>NSURLSessionDataDelegate</code>, <code>NSURLSessionDownloadDelegate</code> 四个代理方法，如果任何子类继承重写这些方法，都必须先调用父类的实现。</p><p><code>initWithSessionConfiguration:</code> 是 <code>AFURLSessionManager</code> 的指定初始化方法，并且在<code>session</code> 初始化指定为其的代理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br></pre></td></tr></table></figure><p>这样的话当一个网络请求的数据有返回或者状态被更改的时候，可以在代理方法中及时获知。<code>AFURLSessionManager</code> 的 <code>session</code> 属性可能会实例化多个 <code>NSURLSessionDataTask</code> 对象，但是 <code>AFURLSessionManager</code> 并不会直接维护它们，而是通过一个可变字典以 <code>task.taskIdentifier</code> 为 key 保存一个私有类 <code>AFURLSessionManagerTaskDelegate</code> 的实例，这个实例会保存这次网络请求的回调、响应数据和进度，两者是一对一的关系。当 <code>AFURLSessionManager</code> 所实现的协议方法被调用时，会及时更新 <code>AFURLSessionManagerTaskDelegate</code> 实例的数据。</p><p>在实现文件中，框架还对 <code>NSURLSessionDataTask</code> 的 <code>resume</code> 和 <code>suspend</code> 方法进行了 Hook，在方法执行的时候发送通知。</p><p>除此之外，<code>AFURLSessionManager</code> 还管理者 <code>AFSecurityPolicy</code> 和 <code>AFNetworkReachabilityManager</code>，来保证请求的安全和查看网络连接情况，它有一个 <code>AFJSONResponseSerializer</code> 的实例来序列化 HTTP 响应。</p><h2 id="AFURLRequestSerialization-和-AFURLResponseSerialization"><a href="#AFURLRequestSerialization-和-AFURLResponseSerialization" class="headerlink" title="AFURLRequestSerialization 和 AFURLResponseSerialization"></a>AFURLRequestSerialization 和 AFURLResponseSerialization</h2><p><code>&lt;AFURLRequestSerialization&gt;</code> 和 <code>&lt;AFURLResponseSerialization&gt;</code> 只是两个协议，并且分别只有一个方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLRequestSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现 <code>&lt;AFURLRequestSerialization&gt;</code> 协议的有 <code>AFHTTPRequestSerializer</code> 及其两个子类： <code>AFJSONRequestSerializer</code> 和 <code>AFPropertyListRequestSerializer</code>，<code>AFHTTPRequestSerializer</code>除了实现协议之外还封装了对 TTPHeader 和 HTTPBody 操作。</p><p>实现 <code>&lt;AFURLResponseSerialization&gt;</code> 协议的有 <code>AFHTTPResponseSerializer</code> 及<code>AFJSONResponseSerializer</code> 等数个子类。</p><p><code>AFHTTPResponseSerializer</code> 有两个属性分来判断接受的 StatusCode 和 ContentType：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSIndexSet</span> *acceptableStatusCodes;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSString</span> *&gt; *acceptableContentTypes</span><br></pre></td></tr></table></figure><p>而 <code>AFJSONResponseSerializer</code> 是 <code>AFHTTPSessionManager</code> 类默认的响应序列化类型。</p><h2 id="AFNetworkReachabilityManager"><a href="#AFNetworkReachabilityManager" class="headerlink" title="AFNetworkReachabilityManager"></a>AFNetworkReachabilityManager</h2><p><code>AFNetworkReachabilityManager</code> 作用是监听网络，是一个比较独立的模块，可以拿出来单独使用。</p><p>指定构造方法： <code>initWithReachability:</code>，<code>AFNetworkReachabilityManager</code> 会持有这个 <code>SCNetworkReachabilityRef</code> 属性。</p><p>调用 <code>startMonitoring</code> 开始监听：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    <span class="comment">// 先停止监听</span></span><br><span class="line">    [<span class="keyword">self</span> stopMonitoring];</span><br><span class="line">    <span class="comment">// 不符合条件，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.networkReachability) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个block作为 SCNetworkReachabilityContext 初始化的第二个参数，参数名：info 参数类型：无类型指针</span></span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建监听上下文</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置监听回调，回调的是 AFNetworkReachabilityCallback 函数，并且callback会被作为参数一起回调</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilitySetCallback</span>(<span class="keyword">self</span>.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">    <span class="comment">// 开始监听</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class="line">    <span class="comment">// 获取当前的网络状态并回调</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>),^&#123;</span><br><span class="line">        <span class="built_in">SCNetworkReachabilityFlags</span> flags;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SCNetworkReachabilityGetFlags</span>(<span class="keyword">self</span>.networkReachability, &amp;flags)) &#123;</span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;版本：AFNetworking 3.1.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;AFNetworking&lt;/em&gt; 主要的几个类或协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AFURLSessionManager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AFNetworkReachabilityManager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AFSecurityPolicy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;AFURLRequestSerialization&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;AFURLResponseSerialization&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="源码阅读" scheme="http://blog.iosgg.cn/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中集合如何弱引用对象</title>
    <link href="http://blog.iosgg.cn/2017/03/08/9-weak_ref_array/"/>
    <id>http://blog.iosgg.cn/2017/03/08/9-weak_ref_array/</id>
    <published>2017-03-08T11:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.691Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-使用-NSValue"><a href="#1-使用-NSValue" class="headerlink" title="1. 使用 NSValue"></a>1. 使用 NSValue</h4><p><code>NSValue</code> 可以弱引用保存一个对象，我们可以使用这种方法间接的引用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithNonretainedObject:<span class="keyword">@selector</span>(<span class="keyword">class</span>)];</span><br><span class="line">[array addObject:value];</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-使用-NSPointerArray，NSMapTable，NSHashTable"><a href="#2-使用-NSPointerArray，NSMapTable，NSHashTable" class="headerlink" title="2. 使用 NSPointerArray，NSMapTable，NSHashTable"></a>2. 使用 NSPointerArray，NSMapTable，NSHashTable</h4><p>以上三个类型的用法分别对应 <code>NSMutableArray</code>，<code>NSMutableDictionary</code>，<code>NSMutableSet</code>。</p><h6 id="NSPointerArray"><a href="#NSPointerArray" class="headerlink" title="NSPointerArray"></a>NSPointerArray</h6><p><code>NSPointerArray</code> 和 <code>NSMutableArray</code> 一样同是有序可变集合，可插入、删除成员；<br>不同的是可以存储 <code>NULL</code>，且 <code>count</code> 可变，用 <code>NULL</code> 来填充。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithOptions:(<span class="built_in">NSPointerFunctionsOptions</span>)options;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPointerFunctions:(<span class="built_in">NSPointerFunctions</span> *)functions;</span><br></pre></td></tr></table></figure><p><code>NSPointerFunctionsOptions</code> 枚举定义着内存管理策略、方法特性和内存标识，以下是几个常用的枚举值：</p><ol><li>内存管理策略：<ul><li><code>NSPointerFunctionsStrongMemory</code>：强引用成员</li><li><code>NSPointerFunctionsMallocMemory</code> 与 <code>NSPointerFunctionsMachVirtualMemory</code>： 用于 Mach 的 虚拟内存管理</li><li><code>NSPointerFunctionsWeakMemory</code>：弱引用成员</li></ul></li><li>方法特性：<ul><li><code>NSPointerFunctionsObjectPersonality</code>：hash、isEqual、对象描述</li><li><code>NSPointerFunctionsOpaquePersonality</code>：pointer 的 hash 、直接判等</li></ul></li><li>内存标识：<ul><li><code>NSPointerFunctionsCopyIn</code> 添加成员时进行 copy 操作</li></ul></li></ol><p>选用多种组合方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSPointerFunctionsOptions</span> options = <span class="built_in">NSPointerFunctionsStrongMemory</span> | <span class="built_in">NSPointerFunctionsObjectPersonality</span> | <span class="built_in">NSPointerFunctionsCopyIn</span>;</span><br><span class="line"><span class="built_in">NSHashTable</span> *table = [<span class="built_in">NSHashTable</span> hashTableWithOptions:options];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> IsEqual(<span class="keyword">const</span> <span class="keyword">void</span> *item1, <span class="keyword">const</span> <span class="keyword">void</span> *item2, <span class="built_in">NSUInteger</span> (*size)(<span class="keyword">const</span> <span class="keyword">void</span> *item)) &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">const</span> <span class="keyword">int</span> *)item1 == *(<span class="keyword">const</span> <span class="keyword">int</span> *)item2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSPointerFunctions</span> *functions = [[<span class="built_in">NSPointerFunctions</span> alloc] init];</span><br><span class="line">[functions setIsEqualFunction:IsEqual];</span><br></pre></td></tr></table></figure><h6 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h6><p><code>NSMapTable</code> 和 <code>NSPointerArray</code> 的初始化方法和使用都类似，不同的是 <code>NSMapTable</code> 的 key 和 object 各有不同的策略，所以有四种组合：</p><table><thead><tr><th>key</th><th>object</th></tr></thead><tbody><tr><td>weak</td><td>weak</td></tr><tr><td>strong</td><td>weak</td></tr><tr><td>weak</td><td>strong</td></tr><tr><td>strong</td><td>strong</td></tr></tbody></table><p>如果 key 或者 object 是 <code>weak</code> 修饰时，任意一方在内存中被释放都会移除该键值对。</p><h6 id="NSHashTable"><a href="#NSHashTable" class="headerlink" title="NSHashTable"></a>NSHashTable</h6><p><code>NSHashTable</code> 使用方法类似于 <code>NSMutableSet</code>，只不过该类型的 <code>allObjectes</code> 属性返回的是一个 <code>NSArray</code>，会对成员强引用。</p><h4 id="3-根据-NSValue-的思路自己写一个类"><a href="#3-根据-NSValue-的思路自己写一个类" class="headerlink" title="3. 根据 NSValue 的思路自己写一个类"></a>3. 根据 NSValue 的思路自己写一个类</h4><p>新建一个 <code>WeakRef</code> 类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakRef</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> ref;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WeakRef *weakRef = [WeakRef new];</span><br><span class="line">weakRef.ref = xxx;</span><br><span class="line">[array addObject:weakRef];</span><br></pre></td></tr></table></figure><h4 id="4-根据-NSValue-的思路自己写一个-block"><a href="#4-根据-NSValue-的思路自己写一个-block" class="headerlink" title="4. 根据 NSValue 的思路自己写一个 block"></a>4. 根据 NSValue 的思路自己写一个 block</h4><p>声明和定义一个 block：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span>(^WeakRefBlock)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span>(^MakeWeakRefBlock)(<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line">MakeWeakRefBlock makeWeakRef (<span class="keyword">id</span> object) &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> weakref = object;</span><br><span class="line">     WeakRefBlock block = ^()&#123;</span><br><span class="line">        <span class="keyword">return</span> weakref;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[array addObject:makeWeakRef([<span class="built_in">NSObject</span> new])];</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-使用-NSValue&quot;&gt;&lt;a href=&quot;#1-使用-NSValue&quot; class=&quot;headerlink&quot; title=&quot;1. 使用 NSValue&quot;&gt;&lt;/a&gt;1. 使用 NSValue&lt;/h4&gt;&lt;p&gt;&lt;code&gt;NSValue&lt;/code&gt; 可以弱引用保存一个对象，我们可以使用这种方法间接的引用。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSValue&lt;/span&gt; *value = [&lt;span class=&quot;built_in&quot;&gt;NSValue&lt;/span&gt; valueWithNonretainedObject:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[array addObject:value];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="弱引用" scheme="http://blog.iosgg.cn/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>不要滥用懒加载</title>
    <link href="http://blog.iosgg.cn/2017/02/17/8-dont_abuse_lazy_load/"/>
    <id>http://blog.iosgg.cn/2017/02/17/8-dont_abuse_lazy_load/</id>
    <published>2017-02-17T13:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.691Z</updated>
    
    <content type="html"><![CDATA[<p>写代码是一种习惯的养成，一种生活的态度。</p><p>以前学 iOS 开发的时候，喜欢在 ViewController 和 Cell 里初始化视图，还有数据模型数组的时候，是用的懒加载（Lazy-Load）。为什么这么喜欢用懒加载来实例化一个属性呢？</p><ol><li>觉得懒加载可以延迟加载，需要的时候才去加载数据；</li><li>数组和字典等集合类型还可以防止为初始化或者使用中被置为 <code>nil</code>；</li><li>类的属性多了这么写看着更舒服、清晰<br>。。。</li></ol><a id="more"></a><p>基本上每个属性我都希望去懒加载实现它，这会给我一种错觉：这样写更好，性能更高！</p><p>其实，这是一个不好的习惯，随着编程时间越发的长，越是觉得之前有些偏激。</p><p>iOS 中懒加载的写法一般为重写 <code>getter</code> 方法，判断属性是否为 <code>nil</code> ，是的话去初始化，否就直接返回：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)layerView &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_layerView) &#123;</span><br><span class="line">        _layerView = [<span class="built_in">UIView</span> new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _layerView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是我们有更清晰、简洁的写法</strong></p><p>一般来说，如果 <code>layerView</code> 是控制器的属性，我们一般都会在 <code>viewDidLoad</code> 方法中去加载视图；如果是一个视图，我们一般会在 <code>initWithFrame:</code> 加载子视图，我们只需要安安静静的用以下代码来初始化即可：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_layerView = [<span class="built_in">UIView</span> new];</span><br></pre></td></tr></table></figure><p> 根本无需使用懒加载，因为如果你不是一个人在开发的话，你<em>永远不会知道你的队友会在 <code>get</code> 方法里面做什么</em>。</p><p> 而且这样写更简洁，更清晰。当属性很多的时候也可以使用以下方式来初始化：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.layerView = (&#123;</span><br><span class="line">    [<span class="built_in">UIView</span> new];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用懒加载至少六行代码，现在只需要一行或者三行就可以做到。</p><p><strong>我们不能使用懒加载来防止那些可能出现的错误</strong></p><p>很大一部分人用懒加载是为了保证数组和字典等集合类型在使用中永远不会是空值，这是错误的做法，因为可变集合类型被初始化之后，在正确的使用中如果不会被置 <code>nil</code>，那么也无需使用懒加载。如果因此而引发的问题，也可以帮我们提前找到原因。</p><p><strong>对于耗时或性能很大的操作，我们可以使用惰性计算而不是懒加载</strong></p><p>比如，我重构项目遇到的一个需求：请求股票列表返回的数据会告诉我总共会有上千条数据，并且不做分页，就是全部展示，滑到第几条就去请求第几条的数据。</p><p>上千条数据不做分页，我们也不可能全部请求回来，即便能全部请求回来也不可能在一个方法里去做这样的操作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *dataArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">  [dataArray addObject:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，对于 TableView 来讲，上千条数据，当然需要 Array 的 count 返回是一千。这个时候我们可以用<a href="https://zh.wikipedia.org/zh-hant/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC" target="_blank" rel="noopener">惰性计算</a>来解决这个问题：有多少条数据，我们就让数组返回的 count 是多少，但是只有真正的向数组取这个下标的对象的时候，我们才去处理！</p><p>那我们继承 NSArray 来写（真正的写一个 NSArray 还需要重写其他几个方法，在此不细说）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span>(^HTLazyArrayItemBlock)(<span class="built_in">NSInteger</span> index);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTLazyArray</span> : <span class="title">NSArray</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithItemBlock:(HTLazyArrayItemBlock)block count:(<span class="built_in">NSInteger</span>)count;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"HTLazyArray.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTLazyArray</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) HTLazyArrayItemBlock block;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HTLazyArray</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> _ct;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithItemBlock:(HTLazyArrayItemBlock)block count:(<span class="built_in">NSInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _ct = count;</span><br><span class="line">        <span class="keyword">self</span>.block = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - override</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _ct;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.block(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们初始化的时候传入一个 count，被 TableView 的代理方法访问的时候，有则返回数据模型，没有就先返回 <code>nil</code>，待到网络请求到数据再进行刷新。这样做的性能损耗微乎其微。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.lazyArray = [[HTLazyArray alloc]initWithItemBlock:^<span class="keyword">id</span>(<span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">       HTQuoteAHCellModel *model = weakSefl.cache[@(index)];</span><br><span class="line">       <span class="keyword">return</span> model;</span><br><span class="line">   &#125; count:dataTotalCount];</span><br></pre></td></tr></table></figure><p><strong>那么，我们到底什么时候该用懒加载呢？</strong></p><p>懒加载的使用需要看具体的场景，比如一个很可能不会被使用的属性，使用懒加载确实可以避免无所谓的性能损耗；<br>还有就是 <code>null_resettable</code> 修饰的属性，该属性意为：setter nullable，但是 getter nonnull，典型的就是控制器的 <code>view</code> 属性：“你可以不要我，把我置空；但只要你需要我，我就是在的”。诸如此类都可以使用懒加载。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写代码是一种习惯的养成，一种生活的态度。&lt;/p&gt;
&lt;p&gt;以前学 iOS 开发的时候，喜欢在 ViewController 和 Cell 里初始化视图，还有数据模型数组的时候，是用的懒加载（Lazy-Load）。为什么这么喜欢用懒加载来实例化一个属性呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;觉得懒加载可以延迟加载，需要的时候才去加载数据；&lt;/li&gt;
&lt;li&gt;数组和字典等集合类型还可以防止为初始化或者使用中被置为 &lt;code&gt;nil&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;类的属性多了这么写看着更舒服、清晰&lt;br&gt;。。。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="懒加载" scheme="http://blog.iosgg.cn/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Swift 语法初窥</title>
    <link href="http://blog.iosgg.cn/2016/10/05/7-swift_basic_grammar/"/>
    <id>http://blog.iosgg.cn/2016/10/05/7-swift_basic_grammar/</id>
    <published>2016-10-05T14:09:42.000Z</published>
    <updated>2022-06-24T17:09:19.690Z</updated>
    
    <content type="html"><![CDATA[<p><strong>References：</strong> <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309" target="_blank" rel="noopener">The Swift Programming Language</a></p><blockquote><p>某程序员对书法十分感兴趣，退休后决定在这方面有所建树。于是花重金购买了上等的文房四宝。一日，饭后突生雅兴，一番磨墨拟纸，并点上了上好的檀香，颇有王羲之风范，又具颜真卿气势，定神片刻，泼墨挥毫，郑重地写下一行字：<code>hello world</code>。</p></blockquote><a id="more"></a><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, World"</span>)</span><br></pre></td></tr></table></figure><!--more--><h2 id="Swift-的基础语法"><a href="#Swift-的基础语法" class="headerlink" title="Swift 的基础语法"></a>Swift 的基础语法</h2><h3 id="值与类型"><a href="#值与类型" class="headerlink" title="值与类型"></a>值与类型</h3><p>定义变量用 <code>var</code>，常量用 <code>let</code>。常量只能赋值一次，但不用必须在声明的时候去赋值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVariable = <span class="number">42</span></span><br><span class="line">myVariable = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myConstant = <span class="number">42</span></span><br></pre></td></tr></table></figure><p>编译器会自动推断常量和变量的类型，但是如果推断不出来（比如说没有初始值等），就需要声明类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> helloTalk : <span class="type">String</span></span><br><span class="line">helloTalk = <span class="string">"helloTalk"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> helloTalk = <span class="string">"helloTalk"</span></span><br></pre></td></tr></table></figure><p><strong>Swift</strong>的值不会隐式被转为其他类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> widthFloat = <span class="number">93.33</span>          <span class="comment">// 自动推断 为 Double</span></span><br><span class="line"><span class="keyword">let</span> width : <span class="type">Int</span> = widthFloat    <span class="comment">// 把 Double 赋值给 Int，会报错</span></span><br><span class="line"><span class="keyword">let</span> widthLabel = label + <span class="type">String</span>(width)</span><br><span class="line"><span class="comment">// 把值转换成字符串还可以这样： \(ValueName)</span></span><br><span class="line"><span class="keyword">let</span> widthString = <span class="string">"width: \(width)."</span></span><br></pre></td></tr></table></figure><p><strong>创建、定义一个数组或者字典</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray = [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">let</span> emptyDictionary = [<span class="type">String</span>: <span class="type">Float</span>]()</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> emptyArray = []</span><br><span class="line"><span class="keyword">let</span> emptyDictionary = [:]</span><br></pre></td></tr></table></figure><p>数组和字典都是集合类型，对于这种类型的 <code>let</code> 和 <code>var</code> 修饰并非是像普通值的可否赋值。<br>比如说，用 <code>let</code> 修饰的数组是不能添加和移除数组中的元素，数组中的元素个数、位置均不可变，但是用 <code>var</code> 修饰的数组可以添加/删除元素。</p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举是为一组相关的值定义了一个共同类型，在 <code>Swift</code> 中，枚举是“一等公民”。枚举成员的原始值不仅可以是整形，还可以是字符、字符串、浮点型；此外，枚举还支持属性、方法、甚至是构造函数、扩展和遵守协议。</p><p>用 <code>enum</code> 关键词来创建枚举：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者用逗号分隔写作一行：</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> direction: <span class="type">Direction</span> = .west</span><br></pre></td></tr></table></figure><p><strong>原始值</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north = <span class="string">"北"</span></span><br><span class="line">    <span class="keyword">case</span> south = <span class="string">"南"</span></span><br><span class="line">    <span class="keyword">case</span> east = <span class="string">"东"</span></span><br><span class="line">    <span class="keyword">case</span> west = <span class="string">"西"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> north = <span class="type">Direction</span>.north     <span class="comment">// the sanme as : let north = Direction(rawValue: "北")</span></span><br><span class="line">north.rawValue  <span class="comment">// "北"</span></span><br></pre></td></tr></table></figure><p><strong>关联值</strong></p><p>Swift 的枚举可以存储各个类型的关联值，而且每个成员的类型可以都不一样。所以对于一个网络请求可以有这样的抽象：一个网络请求的<em>结果</em>，可以是<em>成功</em>或者<em>失败</em>的，如果成功则返回的是我们想要的<em>数据</em>，不成功返回<em>错误原因</em>，那么可以写成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Value</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Value</code> 是泛型语法，可以是任何你需要的类型。</p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p> <strong>for-in</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> persons = [<span class="string">"person1"</span>,<span class="string">"person2"</span>]</span><br><span class="line"><span class="keyword">for</span> personString <span class="keyword">in</span> persons &#123;</span><br><span class="line">  <span class="built_in">print</span>(personString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历字典</span></span><br><span class="line"><span class="keyword">let</span> dict = [</span><br><span class="line">            <span class="string">"name"</span> : <span class="string">"Joke"</span>,</span><br><span class="line">            <span class="string">"age"</span>  : <span class="number">16</span></span><br><span class="line">        ] <span class="keyword">as</span> [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> (key,value) <span class="keyword">in</span> dict &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(key) : \(value)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>if-else</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2</span>&gt;<span class="number">1</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"2 大于 1"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"2 还是大于 1 啊"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code> 后面必须是布尔表达式，如果是一个值的话不会隐式的与 0 比较。</p><p><strong>switch</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable = <span class="string">"red pepper"</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"celery"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Add some raisins and make ants on a log."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cucumber"</span>, <span class="string">"watercress"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"That would make a good tea sandwich."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"pepper"</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Is it a spicy \(x)?"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Everything tastes good in soup."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code> 不仅支持基本数据类型。另外Swift中的<code>switch</code>语法可以省略<code>break</code>。但是不能省略 <code>default</code>，会报 <code>Switch must be exhaustive, consider adding a default clause</code> 的编译错误。</p><p><strong>while</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">100</span> &#123;</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">while</span> i &lt; <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="Swift-的函数和闭包"><a href="#Swift-的函数和闭包" class="headerlink" title="Swift 的函数和闭包"></a>Swift 的函数和闭包</h2><p>函数的关键字是 <code>func</code> ，函数定义的格式是：</p><p><img src="/images/swift-function.png" alt="swift-function"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(para:paraType)</span></span> -&gt; returnType&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的参数标签"><a href="#函数的参数标签" class="headerlink" title="函数的参数标签"></a>函数的参数标签</h3><p>其中参数的那部分的详细结构是用小括号括起来，参数名，冒号，参数类型： <code>(number:Int)</code>。<br>在默认情况下，函数的参数标签使用参数名，或者用 <code>_</code> 不使用参数标签，也可以自定义标签，我们定义一个奇葩的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 求和<span class="params">(数字<span class="number">1</span> num1:Float, 数字<span class="number">2</span> num2:Float)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>求和</strong> 就是方法名，<strong>数字1</strong> 就是自定义的参数标签。调用时会显示标签：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = 求和(数字<span class="number">1</span>: <span class="number">2</span>, 数字<span class="number">2</span>: <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><p><code>swift</code> 还可以用元组返回多个返回值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(numarray:<span class="params">([Int])</span></span></span>) -&gt; (<span class="built_in">min</span>:<span class="type">Int</span>, <span class="built_in">max</span>:<span class="type">Int</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> <span class="built_in">min</span> = numarray[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">var</span> <span class="built_in">max</span> = numarray[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">for</span> num <span class="keyword">in</span> numarray &#123;</span><br><span class="line">       <span class="keyword">if</span> num &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">           <span class="built_in">max</span> = num</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="built_in">min</span>&#123;</span><br><span class="line">           <span class="built_in">min</span> = num</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (<span class="built_in">min</span>, <span class="built_in">max</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时获取返回值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compare(numarray: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]).<span class="built_in">max</span></span><br></pre></td></tr></table></figure><h3 id="函数嵌套函数"><a href="#函数嵌套函数" class="headerlink" title="函数嵌套函数"></a>函数嵌套函数</h3><p><code>swift</code> 语法中函数可以嵌套函数，用于分割太长或者太复杂的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要在意逻辑，只是为了示例一下。。。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumWithArray</span><span class="params">(numArray:<span class="params">([Int])</span></span></span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(num1:Int, num2:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> num1 + num2</span><br><span class="line">   &#125;</span><br><span class="line">   sum = add(num1: numArray[<span class="number">0</span>], num2: numArray[<span class="number">1</span>])</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回一个函数"><a href="#返回一个函数" class="headerlink" title="返回一个函数"></a>返回一个函数</h3><p>函数还可以用一个函数做为返回值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMethod</span><span class="params">()</span></span> -&gt; ((<span class="type">Int</span>)-&gt;(<span class="type">Int</span>)) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(num:Int)</span></span>-&gt;(<span class="type">Int</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> num+<span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> addOne</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"makeMethod()(1993): "</span>,makeMethod()(<span class="number">1993</span>))</span><br><span class="line"><span class="comment">// makeMethod()(1993):  1994</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">makeMethod() 返回的是一个函数，继续传入参数 1993，最后返回 1994</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="传入一个函数"><a href="#传入一个函数" class="headerlink" title="传入一个函数"></a>传入一个函数</h3><p>函数可以把一个函数当做返回值返回，也可以当做一个参数来传入：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfMaxMin</span><span class="params">(numarray:<span class="params">([Int])</span></span></span>,compare:(<span class="number">_</span> numarray:([<span class="type">Int</span>]))-&gt;(<span class="built_in">min</span>:<span class="type">Int</span>, <span class="built_in">max</span>:<span class="type">Int</span>)) -&gt; (<span class="type">Int</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> compare(numarray).<span class="built_in">max</span> + compare(numarray).<span class="built_in">min</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到， <code>sumOfMaxMin</code> 函数有两个参数：<code>numarray:([Int])</code> 和 <code>compare:(_ numarray:([Int]))-&gt;(min:Int, max:Int)</code> 。其中 <code>compare</code> 是一个函数。</p><p>在调用的时候：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfMaxMinValue = sumOfMaxMin(numarray: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],compare: compare)</span><br></pre></td></tr></table></figure><p><code>compare</code> 是上个例子中的函数。当然，我们也可以不传入一个现成已经定义和实现的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfMaxMinValue = sumOfMaxMin(numarray: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) &#123; (numarray:([<span class="type">Int</span>])) -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">min</span> = numarray[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">max</span> = numarray[<span class="number">0</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> num <span class="keyword">in</span> numarray &#123;</span><br><span class="line">      <span class="keyword">if</span> num &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">          <span class="built_in">max</span> = num</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="built_in">min</span>&#123;</span><br><span class="line">          <span class="built_in">min</span> = num</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">min</span>, <span class="built_in">max</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数是一种特殊的闭包"><a href="#函数是一种特殊的闭包" class="headerlink" title="函数是一种特殊的闭包"></a>函数是一种特殊的闭包</h3><p>大家伙看到这里，肯定会一拍大腿：哎呦，这玩意不就是闭包嘛！</p><blockquote><p>（The Swift Programming Language）函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 </p></blockquote><p>我们可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型声明与闭包函数体进行分离。 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] </span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;</span><br><span class="line">  (num:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> newNum = num * <span class="number">3</span></span><br><span class="line">  <span class="keyword">return</span> newNum</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="闭包的简写"><a href="#闭包的简写" class="headerlink" title="闭包的简写"></a>闭包的简写</h3><p>如果闭包的类型已知，那么可以省略参数和返回值的类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;</span><br><span class="line">  num <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> newNum = num * <span class="number">3</span></span><br><span class="line">  <span class="keyword">return</span> newNum</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>单个语句闭包会把它语句的值当做结果返回</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;</span><br><span class="line">  num <span class="keyword">in</span></span><br><span class="line">  num * <span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果把上面的闭包写成一行的话</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;num <span class="keyword">in</span> num * <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>我们可以通过参数位置而不是参数名字来引用参数，那么上面的代码就变成这样</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>(&#123;$<span class="number">0</span> * <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>当一个闭包是传给函数的唯一参数，我们可以完全忽略括号 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numArray:([<span class="type">Int</span>]) = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> newNumArray:([<span class="type">Int</span>]) = numArray.<span class="built_in">map</span>&#123;$<span class="number">0</span> * <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Swift-的类和对象"><a href="#Swift-的类和对象" class="headerlink" title="Swift 的类和对象"></a>Swift 的类和对象</h2><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>类定义的关键字是 <code>class</code>，我们用 <code>class</code> + <strong>类名</strong> + “<strong>:</strong>“ + <strong>父类</strong>，比如定义一个 <code>Person</code> 类，类中去声明和定义变量和函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello ~"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的扩展</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;  <span class="comment">// 给人加一个飞的功能...</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h4><p>存储属性就是存储在类或者结构体一个实例里的一个常量和变量，用 <code>var</code> 或者 <code>let</code> 修饰。</p><p>但是如果一个结构体实例被声明为常量，那么即便这个结构体的某个属性是变量，也是不能去改变的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line">point.x = <span class="number">10</span>    <span class="comment">// 编译是不会通过的</span></span><br></pre></td></tr></table></figure><p><strong>延迟存储属性</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> nameLabel:<span class="type">UILabel</span> = &#123;</span><br><span class="line">   <span class="keyword">let</span> label = <span class="type">UILabel</span>()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> label</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>其实就是把一个立即执行的闭包的返回值赋值给属性，以达到懒加载的目的。</p><p><strong>属性观察器</strong></p><p><code>willSet</code> 在新的值被设置之前调用<br><code>didSet</code> 在新的值被设置之后立即调用<br>需要注意的是：当为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。</p><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>计算属性提供了一个 <code>getter</code> 和一个可选的 <code>setter</code> 。属性的 <code>getter</code> 和 <code>setter</code> 的关键词是 <code>get</code> 和 <code>set</code> ，在 <code>setter</code> 中新值是 <code>newValue</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> birthYear: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> age : <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">           <span class="keyword">self</span>.age = newValue</span><br><span class="line">           <span class="keyword">self</span>.birthYear = <span class="number">2016</span> - newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只读计算属性</strong></p><p>当一个属性只有 <code>getter</code> 而没有 <code>setter</code> 时，那么它就是一个只读计算属性</p><h4 id="类对象的实例和访问："><a href="#类对象的实例和访问：" class="headerlink" title="类对象的实例和访问："></a>类对象的实例和访问：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">person.age = <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="类的构造和析构"><a href="#类的构造和析构" class="headerlink" title="类的构造和析构"></a>类的构造和析构</h3><p>我们可以给 <code>Person</code> 自定义一个构造函数，构造函数中需要给所有的存储型属性一个赋值或者默认值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">   <span class="keyword">self</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以用 <code>name</code> 来实例化一个对象： <code>var person = Person(name:&quot;Tom&quot;)</code></p><p>如果所有属性都有默认值，我们没有自定义的构造，系统会生成一个默认的构造函数：<code>var person = Person()</code><br>相应的，如果我们自定义了一个构造函数，那么系统便不会为该类生成默认的构造函数。<br>但是，我们可以把自定义的构造函数写到类的扩展(<code>extension</code>)里，而不是类的原始定义里面。</p><p>与构造函数对应的是析构函数：<code>deinit</code></p><p><strong>指定构造器和便利构造器</strong><br>指定构造器里面会初始化类实例所有的属性，所以为了保证继承的属性也能被初始化，子类的指定构造器都会调用父类的指定构造器，而类的便利构造器总是会调用本类的指定构造器。<br>也就是说：<strong>指定构造器需要向上调用，便利构造器需要横向调用</strong></p><p>所以，我们可以把父类的指定构造函数重写成便利构造，却不能重写父类的便利构造。即便<em>重写</em>了父类的便利构造函数，但是由于我们不能直接调用父类的便利构造函数，所以不用给函数以 <code>override</code> 修饰。</p><p><strong>必要构造器</strong> 如果某个构造函数被 <code>required</code> 修饰，那么该函数就是必要构造函数，子类继承该类时都必须要实现改构造函数。在子类重写父类的构造函数的时候，也要加 <code>required</code> 来修饰，以确定继承链上子类的子类也遵守。</p><p>除了构造和析构函数，类还有实例的私有函数、公共函数和静态函数。</p><h3 id="类、函数的访问控制（访问、继承-重载-权限）"><a href="#类、函数的访问控制（访问、继承-重载-权限）" class="headerlink" title="类、函数的访问控制（访问、继承/重载 权限）"></a>类、函数的访问控制（访问、继承/重载 权限）</h3><p><code>Swift</code> 中的访问控制有 <strong>模块</strong> 和 <strong>源文件</strong> 两个概念。用 “import” 导入的就是模块。</p><p>对于类而言的修饰词与权限：</p><table><thead><tr><th>修饰词</th><th>权限</th></tr></thead><tbody><tr><td><code>open</code></td><td>修饰的类可以随意继承与访问</td></tr><tr><td><code>public</code></td><td>修饰的类只能在本模块内被继承，但是可以随便访问</td></tr><tr><td><code>internal</code></td><td>默认 - 模块内拥有访问权限</td></tr><tr><td><code>fileprivate</code></td><td>是文件外部不能被访问</td></tr><tr><td><code>private</code></td><td>是文件内部不能被访问</td></tr><tr><td><code>final</code></td><td>是文件内部也不能被继承</td></tr></tbody></table><p>当然了，对于一个 <code>internal</code> 的类，其属性和方法的级别是不会超出类本身的，比如不可能是 <code>public</code> 。</p><p>函数也是同样的修饰词和权限，只是类的继承对应函数的重载权限。<br>函数除了以上几个，常用的修饰词还有 <code>static</code> 和 <code>override</code>。</p><p><code>static</code>修饰的是类方法。<code>override</code>修饰的是重写父类的方法。</p><h2 id="Swift-中的类和结构体"><a href="#Swift-中的类和结构体" class="headerlink" title="Swift 中的类和结构体"></a>Swift 中的类和结构体</h2><p><code>Swift</code> 中的结构体的能力被大大加强，不仅可以拥有属性，还以有方法、构造函数、甚至是扩展和遵守协议。这样的结构体和类有很多相同点：</p><ul><li>属性：存储数据</li><li>方法：提供一些功能</li><li>下标：可以使用下标语法</li><li>构造器：生成初始化值</li><li>扩展：增加功能</li><li>协议：提供某种通用功能</li></ul><p>当然，类和结构体也有很多不同的地方，类还有许多独有的附加功能：</p><ul><li>继承：一个类可以继承另一个类的特征</li><li>类型转换：运行时检查和解释一个类实例的类型</li><li>析构器：一个类实例释放任何其所被分配的资源</li><li>引用计数：对一个类的多次引用</li></ul><p><strong>结构体会提供一个默认的构造函数</strong>，这个构造函数是结构体所有的属性分别作为参数来构建：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point:<span class="type">MyPoint</span> = <span class="type">MyPoint</span>(x: <span class="number">1</span>, y: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>结构体和枚举都是值类型</strong>，值类型在赋值（给变量或者常量）和传递（作为参数给一个函数）的时候都会被拷贝，值类型实例的值属性也会被拷贝。<br><code>Swift</code> 中的整型、浮点型、布尔型、字符串、字典、数组都是值类型，底层都是由结构体来实现的。</p><p><strong>类是引用类型</strong>，引用类型在赋值和传递的时候，内容并不会被拷贝。因此赋值的实例和被赋值的实例其实是一份内容，内容在内存中也是一份。</p><p><strong>值类型和引用类型的区别</strong>在于，值类型在赋值和传递的时候是深拷贝，而引用类型是浅拷贝。<br>深拷贝就是把内存地址中存放的内容也拷贝一份内存中的内容就会有两份；而浅拷贝只是拷贝了内存的地址，内存中的内容还是只有一份。</p><p><img src="/images/%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" alt="值和引用类型的区别"></p><p>但需要注意的是，在 <code>Swift</code> 中，并不是值类型一旦被赋值和传递的时候就会被拷贝一份，只有当需要的时候，比如被赋值的实例去改变内容的时候才会真正的去拷贝。</p><p><strong>那么，我们到底如何选择结构体或者类呢</strong>？如果你只是用来做以下功能是可以选择结构体：</p><ul><li>只是用来封装一些相关的数据</li><li>这些数据被赋值或者传递的时候会被拷贝一份</li><li>不需要被继承</li></ul><p>比如 <code>CGPoint</code>、<code>CGRect</code>、<code>CGSize</code>等都是结构体。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;References：&lt;/strong&gt; &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Swift Programming Language&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;某程序员对书法十分感兴趣，退休后决定在这方面有所建树。于是花重金购买了上等的文房四宝。一日，饭后突生雅兴，一番磨墨拟纸，并点上了上好的檀香，颇有王羲之风范，又具颜真卿气势，定神片刻，泼墨挥毫，郑重地写下一行字：&lt;code&gt;hello world&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    <category term="Swift" scheme="http://blog.iosgg.cn/categories/iOS/Swift/"/>
    
    
    <category term="Swift" scheme="http://blog.iosgg.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>科学上网：用 VPS 搭建 Shadowsocks 服务器</title>
    <link href="http://blog.iosgg.cn/2016/08/08/6-shadowsocks_vps_gfw/"/>
    <id>http://blog.iosgg.cn/2016/08/08/6-shadowsocks_vps_gfw/</id>
    <published>2016-08-08T13:12:23.000Z</published>
    <updated>2022-06-24T17:09:19.690Z</updated>
    
    <content type="html"><![CDATA[<p>假设我们已经有一个 VPS，并且可以 ssh 登陆上去。</p><h2 id="安装-shadowsocks"><a href="#安装-shadowsocks" class="headerlink" title="安装 shadowsocks"></a>安装 shadowsocks</h2><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu:"></a>Debian/Ubuntu:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p>如果第一条命令执行失败的话 : <code>E: Unable to locate package python-pip</code>，就用官方给出了一个安装脚本进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py python get-pip.py</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS:"></a>CentOS:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><h2 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h2><p>shadowsocks 的配置文件设置了启动时的服务器端口、加密方式、密码等参数。</p><p>配置文件中个字段的含义：</p><ul><li>server: 服务器ip地址</li><li>server_port: 绑定的端口，注意不要设置已经使用了的端口</li><li>possword: 密码</li><li>timeout: 超时时间</li><li>method: 加密方法</li><li>fast_open: 如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟</li><li>workers: 默认为1</li></ul><p>用 vi 新建一个配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;shadowsocks.json</span><br></pre></td></tr></table></figure><p>然后输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">   &quot;server&quot;:&quot;my_server_ip&quot;, # 推荐设置为 0.0.0.0</span><br><span class="line">   &quot;server_port&quot;:25, </span><br><span class="line">   &quot;local_address&quot;: &quot;127.0.0.1&quot;, </span><br><span class="line">   &quot;local_port&quot;:1080, </span><br><span class="line">   &quot;password&quot;:&quot;mypassword&quot;,</span><br><span class="line">    &quot;timeout&quot;:300, </span><br><span class="line">   &quot;method&quot;:&quot;aes-256-cfb&quot;, </span><br><span class="line">   &quot;fast_open&quot;: false </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动-shadowsocks"><a href="#启动-shadowsocks" class="headerlink" title="启动 shadowsocks"></a>启动 shadowsocks</h2><p>编写好配置文件就可以启动了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json</span><br></pre></td></tr></table></figure><p>后台启动和关闭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d start </span><br><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d stop</span><br></pre></td></tr></table></figure><p>shadowsocks 的日志保存在 /var/log/shadowsocks.log</p><h2 id="安装并启动-shadowsocks-客户端"><a href="#安装并启动-shadowsocks-客户端" class="headerlink" title="安装并启动 shadowsocks 客户端"></a>安装并启动 shadowsocks 客户端</h2><p>shadowsocks 支持 windows、Mac OS X、Linux、Android、iOS 等多个平台。</p><p>shadowsocks 项目主页： <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a></p><p>iOS 客户端推荐：</p><ul><li><a href="https://appsto.re/cn/_2Fjgb.i" target="_blank" rel="noopener">AnyFlow - 超酷的网络加速和分析工具</a> - (快、省电，新出的)</li><li><a href="https://appsto.re/cn/UDjM3.i" target="_blank" rel="noopener">Shadowrocket</a> - (功能全，更新快)</li><li><a href="https://appsto.re/cn/pD8pgb.i" target="_blank" rel="noopener">Wingy - Http(s) Socks5 Proxy Utility</a> - (免费)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;假设我们已经有一个 VPS，并且可以 ssh 登陆上去。&lt;/p&gt;
&lt;h2 id=&quot;安装-shadowsocks&quot;&gt;&lt;a href=&quot;#安装-shadowsocks&quot; class=&quot;headerlink&quot; title=&quot;安装 shadowsocks&quot;&gt;&lt;/a&gt;安装 shadowsocks&lt;/h2&gt;&lt;h3 id=&quot;Debian-Ubuntu&quot;&gt;&lt;a href=&quot;#Debian-Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;Debian/Ubuntu:&quot;&gt;&lt;/a&gt;Debian/Ubuntu:&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-get install python-pip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install shadowsocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果第一条命令执行失败的话 : &lt;code&gt;E: Unable to locate package python-pip&lt;/code&gt;，就用官方给出了一个安装脚本进行安装：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget https:&amp;#x2F;&amp;#x2F;bootstrap.pypa.io&amp;#x2F;get-pip.py python get-pip.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="工具" scheme="http://blog.iosgg.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="http://blog.iosgg.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发中多线程的那些事</title>
    <link href="http://blog.iosgg.cn/2016/05/22/5-multithreading_iOS/"/>
    <id>http://blog.iosgg.cn/2016/05/22/5-multithreading_iOS/</id>
    <published>2016-05-22T02:11:11.000Z</published>
    <updated>2022-06-24T17:09:19.690Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发深入之后还是要接触多线程和runloop的，写篇博客讲解、记录下iOS开发中的多线程技术。</p><h2 id="线程、进程"><a href="#线程、进程" class="headerlink" title="线程、进程"></a>线程、进程</h2><h3 id="什么是线程、进程"><a href="#什么是线程、进程" class="headerlink" title="什么是线程、进程"></a>什么是线程、进程</h3><p>&emsp;&emsp;有的人说进程就像是人的脑袋，线程就是脑袋上的头发~~。其实这么比方不算错，但是更简单的来说，用迅雷下载文件，迅雷这个程序就是一个进程，下载的文件就是一个线程，同时下载三个文件就是多线程。一个进程可以只包含一个线程去处理事务，也可以有多个线程。</p><a id="more"></a><h3 id="多线程的优点和缺点"><a href="#多线程的优点和缺点" class="headerlink" title="多线程的优点和缺点"></a>多线程的优点和缺点</h3><p>&emsp;&emsp;多线程可以大大提高软件的执行效率和资源（CPU、内存）利用率，因为CPU只可以处理一个线程（多核CPU另说），而多线程可以让CPU同时处理多个任务（其实CPU同一时间还是只处理一个线程，但是如果切换的够快，就可以了认为同时处理多个任务）。但是多线程也有缺点：当线程过多，会消耗大量的CPU资源，而且，每开一条线程也是需要耗费资源的（iOS主线程占用1M内存空间，子线程占用512KB）。</p><h3 id="iOS开发中的多线程"><a href="#iOS开发中的多线程" class="headerlink" title="iOS开发中的多线程"></a>iOS开发中的多线程</h3><p>&emsp;&emsp;iOS程序在启动后会自动开启一个线程，称为 <strong>主线程</strong> 或者 <strong>UI线程</strong> ，用来显示、刷新UI界面，处理点击、滚动等事件，所以耗费时间的事件（比如网络、磁盘操作）尽量不要放在主线程，否则会阻塞主线程造成界面卡顿。<br>iOS开发中的多线程实现方案有四种：</p><table><thead><tr><th>技术方案</th><th>简介</th><th>语言</th><th>生命周期管理</th></tr></thead><tbody><tr><td>pthread</td><td>一套通用的多线程API，适用于Unix\Linux\Windows等系统，跨平台\可移植，使用难度大</td><td>C</td><td>程序员管理</td></tr><tr><td>NSThread</td><td>使用更加面向对象，简单易用，可直接操作线程对象</td><td>Objective-C</td><td>程序员手动实例化</td></tr><tr><td>GCD</td><td>旨在替代NSThread等线程技术，充分利用设备的多核</td><td>C</td><td>自动管理</td></tr><tr><td>NSOperation</td><td>基于GCD（底层是GCD），比GCD多了一些更简单实用的功能，使用更加面向对象</td><td>Objective-C</td><td>自动管理</td></tr></tbody></table><p>多线程中GCD我使用比较多，以GCD为例，多线程有两个核心概念：</p><ol><li>任务 （做什么？）</li><li>队列 （存放任务，怎么做？）</li></ol><p>任务就是你开辟多线程要来做什么？而每个线程都是要加到一个队列中去的，队列决定任务用什么方式来执行。</p><p>线程执行任务方式分为：</p><ol><li>异步执行</li><li>同步执行</li></ol><p>同步执行只能在当前线程执行，不能开辟新的线程。而且是必须、立即执行。而异步执行可以开辟新的线程。</p><p>队列分为：</p><ol><li>并发队列</li><li>串行队列</li></ol><p>并发队列可以让多个线程同时执行（必须是异步），串行队列则是让任务一个接一个的执行。打个比方说，串行队列就是单车道，再多的车也得一个一个的跑（–：我俩车强行并着跑不行？ –：来人，拖出去砍了！），而串行是多车道，可以几辆车同时并着跑。那么到底是几车道？并发队列有个最大并发数，一般可以手动设置。</p><p>那么，线程加入到队列中，到底会怎么执行？</p><table><thead><tr><th></th><th>并发队列</th><th>串行队列（非主队列）</th><th>主队列（只有主线程，串行队列）</th></tr></thead><tbody><tr><td>同步</td><td>不开启新的线程，串行</td><td>不开启新的线程，串行</td><td>不开启新的线程，串行</td></tr><tr><td>异步</td><td>开启新的线程，并发</td><td>开启新的线程，串行</td><td>不开启新的线程，串行</td></tr></tbody></table><p><strong>注意：</strong> </p><ol><li>只用在并发队列异步执行才会开启新的线程并发执行；</li><li>在当前串行队列中开启一个同步线程会造成 <strong>线程阻塞</strong> ，因为上文说过，同步线程需要立即马上执行，当在当前串行队列中创建同步线程时需要在串行队列立即执行任务，而此时线程还需要向下继续执行任务，造成阻塞。</li></ol><p>上面提到线程会阻塞，那么什么是阻塞？除了阻塞之外线程还有其他什么状态？<br>一般来说，线程有五个状态：</p><ul><li>新建状态：线程刚刚被创建，还没有调用 <strong>run</strong> 方法，这个时候的线程就是新建状态；</li><li>就绪状态：在新建线程被创建之后调用了 <strong>run</strong> 方法，但是CPU并不是真正的同时执行多个任务，所以要等待CPU调用，这个时候线程处于就绪状态，随时可能进入下一个状态；</li><li>运行状态：在线程执行过 <strong>run</strong>方法之后，CPU已经调度该线程即线程获取了CPU时间；</li><li>阻塞状态：线程在运行时可能会进入阻塞状态，比如线程睡眠（sleep）；希望得到一个锁，但是该锁正被其他线程拥有。。</li><li>死亡状态：当线程执行完任务或者因为异常情况提前终止了线程</li></ul><h2 id="iOS开发中的多线程的使用"><a href="#iOS开发中的多线程的使用" class="headerlink" title="iOS开发中的多线程的使用"></a>iOS开发中的多线程的使用</h2><h3 id="pthread的使用"><a href="#pthread的使用" class="headerlink" title="pthread的使用"></a>pthread的使用</h3><p>使用下面代码可以创建一个线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> * __restrict, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> * __restrict,<span class="keyword">void</span> *(*)(<span class="keyword">void</span> *), <span class="keyword">void</span> * __restrict)</span></span></span><br></pre></td></tr></table></figure><p>可以看到这个方法有四个参数，主要参数有 <strong>pthread_t * __restrict</strong> ，因为该方法是C语言，所以这个参数不是一个对象，而是一个 <strong>pthread_t</strong> 的地址，还有 <strong>void <em>(</em>)(void *)</strong> 是一个无返回值的函数指针。<br>使用代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * run(<span class="keyword">void</span> *param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread--%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createThread&#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentThread--&lt;<span class="built_in">NSThread</span>: <span class="number">0x7fff38602fb0</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p><strong>number = 1</strong> 的线程是主线程，不为一的时候都是子线程。</p><h3 id="NSThread的使用"><a href="#NSThread的使用" class="headerlink" title="NSThread的使用"></a>NSThread的使用</h3><p>NSThread创建线程一般有三种方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">+ (<span class="keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument</span><br></pre></td></tr></table></figure><ol><li>前两种创建之后会自动执行，第三种方式创建后需要手动执行；</li><li>第一种创建方式是创建一个子线程，类似的 <strong>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array</strong> 方法可以创建并发任务在主线程中执行，<strong>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array</strong> 可以选择在哪个线程中执行。</li></ol><p>示例代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)createThread&#123;</span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="string">@"我是参数"</span>];</span><br><span class="line">thread.name = <span class="string">@"我是线程名字啊"</span>;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">[thread start];</span><br><span class="line"><span class="comment">// 或者 [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@"我是参数"];</span></span><br><span class="line"><span class="comment">// 或者 [self performSelectorInBackground:@selector(run:) withObject:@"我是参数"];</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)run:(<span class="built_in">NSString</span> *)param&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-----run-----%@--%@"</span>, param, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-----run-----我是参数--&lt;<span class="built_in">NSThread</span>: <span class="number">0x7ff8a2f0c940</span>&gt;&#123;number = <span class="number">2</span>, name = 我是线程名字啊&#125;</span><br></pre></td></tr></table></figure><h3 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h3><p>苹果官方对GCD说：</p><blockquote><p>开发者要做的只是定义执行的任务并追加到适当的 Dispatch Queue 中。</p></blockquote><p>在GCD中我们要做的只是两件事：定义任务；把任务加到队列中。</p><h4 id="dispatch-queue-create-获取-创建队列"><a href="#dispatch-queue-create-获取-创建队列" class="headerlink" title="dispatch_queue_create 获取/创建队列"></a>dispatch_queue_create 获取/创建队列</h4><p>GCD 的队列有两种：</p><table><thead><tr><th>Dispatch Queue 种类</th><th>说明</th></tr></thead><tbody><tr><td>Serial Dispatch Queue</td><td>等待现在执行中处理结束（串行队列）</td></tr><tr><td>Concurrent Dispatch Queue</td><td>不等待现在执行中处理结束（并行队列）</td></tr></tbody></table><p>GCD中的队列都是 <strong>dispatch_queue_t</strong> 类型，获取/创建方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 手动创建队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr);</span><br><span class="line"><span class="comment">// 1.1 创建串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.sanyucz.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 1.2 创建并行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.sanyucz.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// 2. 获取系统标准提供的 Dispatch Queue</span></span><br><span class="line"><span class="comment">// 2.1 获取主队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"><span class="comment">// 2.2 获取全局并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>需要说明的是，手动创建队列时候的两个关键参数，<strong>const char *label</strong> 指定队列名称，最好起一个有意义的名字，当然如果你想调试的时候刺激一下，也可以设置为 <strong>NULL</strong>，而 <strong>dispatch_queue_attr_t attr</strong> 参数文档有说明：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @const DISPATCH_QUEUE_SERIAL</span></span><br><span class="line"><span class="comment"> * @discussion A dispatch queue that invokes blocks serially in FIFO order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_SERIAL NULL</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @const DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="comment"> * @discussion A dispatch queue that may invoke blocks concurrently and supports</span></span><br><span class="line"><span class="comment"> * barrier blocks submitted with the dispatch barrier API.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_CONCURRENT \</span></span><br><span class="line">DISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, \</span><br><span class="line">_dispatch_queue_attr_concurrent)</span><br></pre></td></tr></table></figure><ul><li><strong>DISPATCH_QUEUE_SERIAL</strong> 创建串行队列按顺序FIFO（First-In-First-On）先进先出；</li><li><strong>DISPATCH_QUEUE_CONCURRENT</strong> 则会创建并发队列</li></ul><h4 id="dispatch-async-dispatch-sync-创建任务"><a href="#dispatch-async-dispatch-sync-创建任务" class="headerlink" title="dispatch_async/dispatch_sync 创建任务"></a>dispatch_async/dispatch_sync 创建任务</h4><p>创建完队列之后就是定义任务了，有两种方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个同步执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br><span class="line"><span class="comment">// 创建一个异步执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure><p>完整的示例代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.sanyucz.queue.asyncSerial"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"异步 + 串行 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="dispatch-group-任务组"><a href="#dispatch-group-任务组" class="headerlink" title="dispatch group 任务组"></a>dispatch group 任务组</h4><p>我们可能在实际开发中会遇到这样的需求：在两个任务完成后再执行某一任务。虽然这种情况可以用串行队列来解决，但是我们有更加高效的方法。</p><p>直接上代码，在代码的注释中讲解：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取全局并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 创建任务组</span></span><br><span class="line"><span class="comment">// dispatch_group_t ：A group of blocks submitted to queues for asynchronous invocation</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="comment">// 在任务组中添加一个任务</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在任务组中添加另一个任务</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 当任务组中的任务执行完毕之后再执行一下任务</span></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><p>从字面意思就可以看出来这个变量的用处，即阻碍任务执行，它并不是阻碍某一个任务的执行，而是在代码中，在它之前定义的任务会比它先执行，在它之后定义的任务则会在它执行完之后在开始执行。就像一个栏栅。</p><p>使用代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.gcd.barrier"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"----1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"----2-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"----3-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"----4-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---<span class="number">-1</span>-----&lt;<span class="built_in">NSThread</span>: <span class="number">0x7fdc60c0fd90</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line">---<span class="number">-2</span>-----&lt;<span class="built_in">NSThread</span>: <span class="number">0x7fdc60c11500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">----barrier-----&lt;<span class="built_in">NSThread</span>: <span class="number">0x7fdc60c11500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">---<span class="number">-3</span>-----&lt;<span class="built_in">NSThread</span>: <span class="number">0x7fdc60c11500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">---<span class="number">-4</span>-----&lt;<span class="built_in">NSThread</span>: <span class="number">0x7fdc60c0fd90</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><h3 id="NSOperation的使用"><a href="#NSOperation的使用" class="headerlink" title="NSOperation的使用"></a>NSOperation的使用</h3><h4 id="NSOperation-及其子类"><a href="#NSOperation-及其子类" class="headerlink" title="NSOperation 及其子类"></a>NSOperation 及其子类</h4><p><strong>NSOperation</strong> 和 <strong>NSOperationQueue</strong> 配合使用也能实现并发多线程，但是需要注意的是 <strong>NSOperation</strong> 是个抽象类，想要封装操作需要使用其子类。<br>系统为我们提供了两个子类：</p><ul><li>NSInvocationOperation</li><li>NSBlockOperation</li></ul><p>当然，我们也可以自定义其子类，只是需要重写 <strong>main()</strong> 方法。</p><p>先看下系统提供两个子类的初始化方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)sel object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)blockOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br></pre></td></tr></table></figure><p>两个子类初始化方法不一样的地方就是一个用 <strong>实例对象</strong> 和 <strong>方法选择器</strong> 来确定执行一个方法，另外一个是用block闭包保存执行一段代码块。<br>另外 <strong>NSBlockOperation</strong> 还有一个实例方法 <strong>- (void)addExecutionBlock:(void (^)(void))block;</strong> ，只要调用这个方法以至于封装的操作数大于一个就会开启新的线程异步操作。<br>最后调用<strong>NSOperation</strong>的<strong>start</strong>方法启动任务。</p><h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><p><strong>NSOperation</strong> 默认是执行同步任务，但是我们可以把它加入到 <strong>NSOperationQueue</strong> 中编程异步操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addOperation:(<span class="built_in">NSOperation</span> *)op;</span><br><span class="line">- (<span class="keyword">void</span>)addOperations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSOperation</span> *&gt; *)ops waitUntilFinished:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line">- (<span class="keyword">void</span>)addOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br></pre></td></tr></table></figure><p>之前提到过多线程并发队列可以设置最大并发数，以及队列的取消、暂停、恢复操作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置最大并发操作数</span></span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">2</span>; <span class="comment">// 并发队列</span></span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">1</span>; <span class="comment">// 串行队列</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 恢复队列，继续执行</span></span><br><span class="line">queue.suspended = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">// 暂停（挂起）队列，暂停执行</span></span><br><span class="line">queue.suspended = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消队列</span></span><br><span class="line">[queue cancelAllOperations];</span><br></pre></td></tr></table></figure><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>多线程使用的时候，可能会多条线程同时访问/赋值某一变量，如不加限制的话多相处同时访问会出问题。具体情况可以搜索一下相关资料，多线程的 <strong>买票问题</strong> 很是经典。<br>iOS线程安全解决方法一般有以下几种：</p><ul><li>@synchronized 关键字</li><li>NSLock 对象</li><li>NSRecursiveLock 递归锁</li><li>GCD (dispatch_sync 或者 dispatch_barrier_async)</li></ul><p>在iOS中线程安全问题一般是关键字 <strong>@synchronized</strong> 用加锁来完成。<br>示例代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里是安全的，同一时间只有一个线程能到这里哦~~      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 <strong>synchronized</strong> 后面括号里的 <strong>self</strong> 是个 <strong>token</strong> ，该 <strong>token</strong> 不能使用局部变量，应该是全局变量或者在线程并发期间一直存在的对象。因为线程判断该加锁的代码有没有线程在访问是通过该 <strong>token</strong> 来确定的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS开发深入之后还是要接触多线程和runloop的，写篇博客讲解、记录下iOS开发中的多线程技术。&lt;/p&gt;
&lt;h2 id=&quot;线程、进程&quot;&gt;&lt;a href=&quot;#线程、进程&quot; class=&quot;headerlink&quot; title=&quot;线程、进程&quot;&gt;&lt;/a&gt;线程、进程&lt;/h2&gt;&lt;h3 id=&quot;什么是线程、进程&quot;&gt;&lt;a href=&quot;#什么是线程、进程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程、进程&quot;&gt;&lt;/a&gt;什么是线程、进程&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;有的人说进程就像是人的脑袋，线程就是脑袋上的头发~~。其实这么比方不算错，但是更简单的来说，用迅雷下载文件，迅雷这个程序就是一个进程，下载的文件就是一个线程，同时下载三个文件就是多线程。一个进程可以只包含一个线程去处理事务，也可以有多个线程。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="多线程" scheme="http://blog.iosgg.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>runtime 源码学习笔记</title>
    <link href="http://blog.iosgg.cn/2016/04/08/4-runtime/"/>
    <id>http://blog.iosgg.cn/2016/04/08/4-runtime/</id>
    <published>2016-04-08T09:53:13.000Z</published>
    <updated>2022-06-24T17:09:19.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Objc-中类和对象的本质"><a href="#Objc-中类和对象的本质" class="headerlink" title="Objc 中类和对象的本质"></a>Objc 中类和对象的本质</h2><p>Objc 中任何对象都可以称之为 <code>id</code> 类型，那么看下在 <code>objc.h</code> 对 <code>id</code> 类型的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure><p>注释中的描述是 <em>一个指向类的实例的指针</em>，那么是不是意味一个类的实例即对象就是一个 <code>objc_object</code> 结构体呢？再看源码：</p><a id="more"></a><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa; <span class="comment">// 对象的类信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;          <span class="comment">// 父类</span></span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable；方法缓存列表</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags；类信息存储的地方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读 runtime 的源码可以得出以下结构：</p><p><img src="/images/obj-class-isa.png" alt="obj-class-isa"></p><blockquote><p>注：<code>class_ro_t</code> 中存放的是编译时可以确定的属性、方法和协议等</p></blockquote><ol><li>Objc 中的对象是一个 <code>objc_object</code> 结构体，结构体中第一个变量是 <code>isa_t</code> ，存放着该对象所属类的信息；</li><li>类是一个<code>objc_class</code> 结构体，继承自 <code>objc_object</code> ，所以类也是一个对象，另外还有两个变量进行方法缓存和数据存放，比如变量、方法(实例方法，以 <code>-</code> 开头的方法)和所遵守的协议。</li><li>类的 <code>isa</code> 中存放的类是元类（meta-class），类是一个对象，对象的类型就是元类，元类存放着类的方法(类方法，以 <code>+</code> 开头的方法)。</li><li>元类也是类，所以元类也是对象。元类 <code>isa</code> 变量中存放的类是根元类（一般是 <code>NSObject</code> ）。</li><li>根元类 <code>isa</code> 的类信息指向其自身</li><li>类和元类都是单例</li></ol><p>那么 <code>isa</code> 到底存放了什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;  <span class="comment">// 是否开启指针优化                                    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否关联对象                                    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有 C++ 自定义析构函数                     </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 存放了类的信息</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">// 验证对象是否初始化完整                                    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">// 是否被弱引用           </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;  <span class="comment">// 是否正在析构                                    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数是否在 sidetable 中存储，当对象的 extra_rc 字段存储不下时，会把引用计数存放在 sidetable 中                     </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>  <span class="comment">// 引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc_object</code> 中的 <code>isa</code> 是通过位域+掩码来优化存储。<code>isa</code> 共8个字节64位，其中存放类信息的 <code>shiftcls</code> 占去了 33 位，存放引用计数的 <code>extra_rc</code> 占用了 19 位，验证对象是否初始化完整的 <code>magic</code> 占用 6 位，其他都是只占用了 1 位。</p><p>再看下 <code>class_data_bits_t</code> 中 <code>class_rw_t</code> 的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;         <span class="comment">// 编译期决定的类的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;       <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties;  <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;   <span class="comment">// 协议列表</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">    <span class="keyword">uint32_t</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>const class_ro_t *ro</code> 中存放的是类在编译时期就确定的方法、协议等，分类及运行时添加的属性、方法都在 <code>class_rw_t</code> 存储。但是 <code>class_data_bits_t</code> 中的 data（<code>class_rw_t</code>） 一开始是 <code>const class_ro_t *ro;</code>，在初始运行时环境中的 <code>realizeClass</code> 函数中，重新生成 <code>class_rw_t</code> data。并且通过 <code>attachCategories</code> 函数，将分类的方法、协议等添加到 <code>class_rw_t</code> 中。至此，<code>class_rw_t</code> 存放了一个类所需要的完整信息。</p><h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><p>调用方法（函数）是语言经常使用的功能，在 Objective-C 中专业一点的叫法是 <strong>传递消息(pass a message)</strong>。Objective-C 的方法调用都是 <strong>动态绑定</strong> ，而C语言中函数调用方式是 <strong>静态绑定</strong>  ( <strong>static binding</strong> )，也就是说，在编译时期就能决定和知道在运行时所调用的函数。</p><p>以下面代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayGoodBye</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saySomething</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">sayHello();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">sayGoodBye();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上，上面的代码在编译的时候编译器就知道 <strong>sayHello</strong> 和 <strong>sayGoodBye</strong> 两个函数的存在，函数地址是硬编码在指令之中的。但是如果换一种写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayGoodBye</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saySomething</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line"><span class="keyword">void</span> (*something) ();</span><br><span class="line"><span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">something = sayHello;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">something = sayGoodBye;</span><br><span class="line">&#125;</span><br><span class="line">something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就得使用 <strong>动态绑定</strong> ，待调用的函数地址需要到运行时才能读取出来。<br>在 Objective-C 中，对某一个对象传递消息，会用动态绑定机制来决定到底是调用哪个方法。而Objective-C是 C 的超集，底层是由 C语言实现，但是对象接收消息后会调用哪个方法都是在运行期决定。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> object = [list objectAtIndex:<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>在这行代码中， <strong>list</strong> 称为 <strong>接收者</strong>， <strong>objectAtIndex</strong> 叫做 <strong>选择器</strong>， 选择器和参数合起来称为<strong>消息</strong>。当编译器看到这行代码的时候，会换成标准的C语言函数调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_msgSend</span><span class="params">(id self, SEL cmd, ...)</span></span>;</span><br><span class="line">id lastObject = objc_msgSend(<span class="built_in">list</span>, @selector(objectAtIndex:), parameter);</span><br></pre></td></tr></table></figure><p><strong>objc_msgSend</strong> 这个函数可以接收两个及两个以上的参数，第一个参数是接收者，第二个参数是选择器，后面的参数是保持顺序的原来消息传递的参数，<strong>objc_msgSend</strong> 会依据接收者和选择器来决定调用哪个方法，首先在接收者的方法列表缓存（<code>objc_class/cache_t cache</code>）中寻找，如果方法缓存中找不到就类信息存储的方法列表（<code>objc_class/class_data_bits_t/class_rw_t/methods</code>）中找，如果再找不到就会沿着继承体系（<code>objc_class/superclass/class_data_bits_t/class_rw_t/methods</code>）去向上一层一层的寻找，如果仍旧找不到就会执行 <strong>消息转发(message forwarding)</strong> 。<br>当消息第一次传递之后，objc_msgSend 会将匹配结果进行缓存（<code>objc_class/cache_t cache</code>），下次会直接调用方法。消息传递除了objc_msgSend之外在特殊情况下还会有其他的方法来处理：</p><ul><li><strong>objc_msgSend_stret</strong> 如果待发送的消息返回一个结构体，就会调用这个函数来处理。</li><li><strong>objc_msgSend_fpret</strong> 如果消息返回的是浮点数，就会调用这个函数进行处理。</li><li><strong>objc_msgSendSuper</strong> 如果要传递消息给父类。</li></ul><p><strong>总结：</strong></p><ul><li>消息由 接收者、选择器及参数构成，给某对象 <strong>发送消息( invoke a message )</strong> 也就相当于在该对象上调用方法。</li><li>发送给某对象的全部消息都要有<strong>动态消息派发系统( dynamic message dispatch system )</strong> 来处理。</li></ul><h2 id="Objective-C-的消息转发机制与动态添加方法"><a href="#Objective-C-的消息转发机制与动态添加方法" class="headerlink" title="Objective-C 的消息转发机制与动态添加方法"></a>Objective-C 的消息转发机制与动态添加方法</h2><p>刚才说了运行时的消息传递机制，但是却没有说对象收到消息却无法解读该怎么办。这里就着重介绍当消息传递时无法解读的时候就会启动的 <strong>消息转发机制( message forwarding )</strong>。</p><p>开发可能经常会遇到这种情况：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-04</span><span class="number">-20</span> <span class="number">13</span>:<span class="number">14</span>:<span class="number">07.391</span> runtime[<span class="number">1096</span>:<span class="number">22076</span>] *** Terminating app due to uncaught exception <span class="string">'NSInvalidArgumentException'</span>, reason: <span class="string">'-[AutoDictionary setDate:]: unrecognized selector sent to instance 0x100302f50'</span></span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line"><span class="number">0</span>   CoreFoundation                      <span class="number">0x00007fff9f2d94f2</span> __exceptionPreprocess + <span class="number">178</span></span><br><span class="line"><span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x00007fff90db3f7e</span> objc_exception_throw + <span class="number">48</span></span><br><span class="line"><span class="number">2</span>   CoreFoundation                      <span class="number">0x00007fff9f3431ad</span> -[<span class="built_in">NSObject</span>(<span class="built_in">NSObject</span>) doesNotRecognizeSelector:] + <span class="number">205</span></span><br><span class="line"><span class="number">3</span>   CoreFoundation                      <span class="number">0x00007fff9f249571</span> ___forwarding___ + <span class="number">1009</span></span><br><span class="line"><span class="number">4</span>   CoreFoundation                      <span class="number">0x00007fff9f2490f8</span> _CF_forwarding_prep_0 + <span class="number">120</span></span><br><span class="line"><span class="number">5</span>   runtime                             <span class="number">0x0000000100001c1c</span> main + <span class="number">124</span></span><br><span class="line"><span class="number">6</span>   libdyld.dylib                       <span class="number">0x00007fff91df85ad</span> start + <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type <span class="built_in">NSException</span></span><br></pre></td></tr></table></figure><p>这个异常信息是由 <strong>NSObject</strong> 的 <strong>doesNotRecognizeSelector:</strong> 方法抛出来的，本来是给 <strong>AutoDictionary</strong> 的一个实例对象发送消息，但是该对象并没有 <strong>setDate:</strong> 方法，所以消息转发给了 <strong>NSObject</strong> ，最后抛出异常。</p><p>先看下消息处理机制流程图：</p><p><img src="/images/c1f0660ejw1f51rg5hbhuj213k0is40f.jpg" alt="消息处理机制流程图"></p><p>消息转发分为两阶段三步，第一阶段先看接受消息的对象能不能自己处理这个无法解读的消息，这一步可以动态的添加方法去解读接受这个消息；第二阶段是先看看对象自己不能处理这个消息，能不能交给其他对象来进行处理，在这一步如果仍然无法解读消息，那么就会走最后一步：把和消息有关的所有细节封装到一个 <strong>NSInvocation</strong> 中，再询问一次对象是否能解决。<br>看下三个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 询问对象是否自己处理，是返回YES，一般会在这个方法里面动态添加方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步询问对象把消息交给哪个对象来进行处理</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果走到这一步的话，就把消息的所有信息封装成 NSInvocation 对象进行 "最后通牒"</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure><p>来一段代码示例：<br>新建一个 <strong>AutoDictionary</strong> 类，添加一个 <strong>NSDate</strong> 类型的 <strong>date</strong> 属性，在实现文件里面用 <strong>@dynamic date;</strong> 禁止自动生成存取方法，这样当代码中给 <strong>AutoDictionary</strong> 实例对象的 <strong>date</strong>属性赋值时就会出现消息无法解读的现象。<br><strong>.h</strong> 文件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AutoDictionary</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>.m</strong> 实现文件代码内容：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AutoDictionary</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *backingStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  该类仅在实现文件 实现了</span></span><br><span class="line"><span class="comment"> *  - (NSDate *)date</span></span><br><span class="line"><span class="comment"> *  - (void)setDate:(NSDate *)date</span></span><br><span class="line"><span class="comment"> *  两个方法，用于处理 AutoDictionary 无法解读的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) MethodCreator *methodCreator;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AutoDictionary</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">@dynamic</span> date;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.backingStore = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="keyword">self</span>.methodCreator = [MethodCreator new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 消息转发机制 ：1.动态添加方法 2.后备消息接收者 3.封装NSInvocation，最后通牒</span></span><br><span class="line"><span class="comment">// 3. 封装NSInvocation，最后通牒</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 无法接受消息，选择由谁来接受</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.methodCreator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 动态添加方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selString hasPrefix:<span class="string">@"set"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoDictSetter, <span class="string">""</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoDictGetter, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">id</span> autoDictGetter (<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123;</span><br><span class="line">    AutoDictionary *dict = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="keyword">return</span> [dict.backingStore objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> autoDictSetter (<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> value)&#123;</span><br><span class="line">    AutoDictionary *dict = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="built_in">NSString</span> *key = [selString substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">3</span>, selString.length<span class="number">-4</span>)];</span><br><span class="line">    key = [key lowercaseStringWithLocale:[<span class="built_in">NSLocale</span> currentLocale]];</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        [dict.backingStore setObject:value forKey:key];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [dict.backingStore removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AutoDictionary *dict = [AutoDictionary new];</span><br><span class="line">dict.date = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"dict.date = %@"</span>,dict.date);</span><br></pre></td></tr></table></figure><h2 id="method-swizzling-与AOP编程"><a href="#method-swizzling-与AOP编程" class="headerlink" title="method swizzling 与AOP编程"></a>method swizzling 与AOP编程</h2><p>什么是 <code>AOP</code> : (site: baike.baidu.com)，引用百度百科中的解释就是：</p><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><blockquote><p>主要功能:<br>日志记录，性能统计，安全控制，事务处理，异常处理等等</p><p>主要意图:<br>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p></blockquote><p><strong>iOS 开发中的 AOP</strong><br>在 <strong>Objective-C</strong> 中，类的方法列表会把选择器的名称映射到方法的实现上，这样 <strong>动态消息转发系统</strong> 就可以以此找到需要调用的方法。这些方法是以函数指针的形式来表示，这种指针叫做 <strong>IMP</strong>。<br>如下：</p><p><img src="/images/c1f0660ejw1f51w4zipmhj20c5052glu.jpg" alt="c1f0660ejw1f51w4zipmhj20c5052glu"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> (*IMP) (<span class="keyword">id</span>, SEL, ...)</span><br></pre></td></tr></table></figure><p><code>Objective-C</code> 的 <code>runtime</code> 机制以此提供了获取和交换映射<code>IMP</code>的的接口：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name)；</span><br><span class="line"><span class="comment">// 交换两个方法</span></span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations(Method m1, Method m2)</span><br></pre></td></tr></table></figure><p>我们可以通过上面两个方法来进行选择器和所映射的<code>IMP</code>进行交换：</p><p><img src="/images/c1f0660ejw1f51w5m2wipj20c008874r.jpg" alt="c1f0660ejw1f51w5m2wipj20c008874r"></p><p>来，直接上代码示例，比如我们的要实现功能是在每个控制器的<code>- viewDidLoad</code>方法里面log一下，一般有三种实现方式：</p><ol><li>直接修改每个页面的 <strong>view controller</strong> 代码，简单粗暴；</li><li>子类化 <strong>view controller</strong> ，并让我们的 <strong>view controller</strong> 都继承这些子类；</li><li>使用 <code>Method Swizzling</code> 进行 hook，以达到 <code>AOP</code> 编程的思想</li></ol><p>第一种实现的代码是在每个类的里面都这么写：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    DDLog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是只在基类里面写。然后所有的控制器都继承这个基类。<br>最后一种是最佳的解决方案：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Log</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewDidLoad);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(log_viewDidLoad);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">BOOL</span> success = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Method Swizzling</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)log_viewDidLoad&#123;</span><br><span class="line">    [<span class="keyword">self</span> log_viewDidLoad];</span><br><span class="line">    DDLog(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> </p><ul><li>为什么使用 <code>+ (void)load</code> ？因为父类、子类和分类的该方法是分别调用，互不影响，而且是在类被加载的时候必定会调用的方法。</li></ul><p>那么为什么说“父类、子类和分类的该方法是分别调用”且”类被加载的时候必定会调用的方法“呢？</p><p>在 runtime 源码中的 <code>_objc_init() -&gt; load_images() -&gt; call_load_methods()</code> 函数里，可以发现load方法不是走的消息发送，而是直接使用函数地址指针直接调用，且保证了类的load方法在分类之前调用，父类的load方法再子类之前调用。具体逻辑见伪代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">    <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        call_class_loads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">    more_categories = call_category_loads();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给对象、分类添加实例变量"><a href="#给对象、分类添加实例变量" class="headerlink" title="给对象、分类添加实例变量"></a>给对象、分类添加实例变量</h2><p> 在开发中有时候想给对象实例添加个变量来存储数据，但又无法直接声明，比如说既有类的分类。这个时候我们就可以通过 <strong>关联对象</strong> 在运行时给对象关联一个 <strong>对象</strong> 来存储数据。（注意：并不是真实的添加了一个实例变量）</p><p><strong>关联对象</strong> 可以给某个对象关联其他对象并用<strong>key</strong>来区分其他对象。需要注意的是，存储对象的时候要指明 <strong>存储策略</strong>，用来维护对象的内存管理语义。存储策略是 <strong>objc_AssociationPolicy</strong> 枚举定义，以下是存储策略对应的 <strong>@property</strong>属性：</p><table><thead><tr><th>存储策略类型</th><th>对应的@property属性</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>weak</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>strong, nonatomic</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>copy, nonatomic</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>strong</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>copy</td></tr></tbody></table><!--more--><p>用下面的方法可以管理关联对象：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以根据指定策略给对象关联对象值</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法可以获取对象关联对象值</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法可以删除指定对象的全部关联对象值</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>定义关联对象时需要指定内存管理语义，用来模拟对象对变量的拥有关系</li><li>尽量避免使用关联对象，因为如果出现bug不易于问题排查</li></ul><p><strong>Associated Object的实现方式</strong></p><p><img src="/images/associations.png" alt="associations.png"></p><p>通过源码发现，存储使用的数据结构如上图所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">                              id value,</span></span></span><br><span class="line"><span class="function"><span class="params">                              objc_AssociationPolicy policy)</span></span></span><br></pre></td></tr></table></figure><ol><li><code>AssociationsManager</code> 类中有个静态变量 <code>AssociationsHashMap *_map</code></li><li><code>AssociationsHashMap</code> 中以 <code>object</code> 为 key，value 是 <code>ObjectAssociationMap</code></li><li><code>ObjectAssociationMap</code> 中 key 就是入参 <code>key</code>，value 就是入参 <code>value</code></li></ol><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>做个试验，新建一个 <code>BBObject</code> 类，添加一个属性 <code>bb_name</code>，头文件如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BBObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *bb_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>那么以下代码会输出什么呢：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *name = <span class="string">@"这是 bb_name"</span>;</span><br><span class="line"><span class="keyword">void</span> *cls = (__bridge <span class="keyword">void</span> *)([BBObject <span class="keyword">class</span>]);</span><br><span class="line"><span class="keyword">void</span> *bb_obj = &amp;cls;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[(__bridge BBObject*)bb_obj bb_name]);</span><br></pre></td></tr></table></figure><p>输出的是：<code>2017-12-16 19:55:33.477716+0800 runtime[45876:7116185] 这是 bb_name</code>。</p><p>因为 Objc 中一个完整的对象就是 <strong>首地址指向一个类的连续空间</strong>，为什么是连续空间？那是因为对象还有自己属性变量的值要存储，这也是为什么没有给 <code>bb_obj</code> 的 <code>bb_name</code> 属性赋值，却打印出 <code>name</code> 值的原因，在 iOS 中，栈的地址是由高到低，堆的地址是由低到高，在这段代码中栈中依次压入了 <code>name</code>、<code>bb_obj</code>，而 <code>bb_obj</code> 对象自身的属性是根据自身首地址进行偏移去获取，所以会取到 <code>name</code> 的值。</p><p><img src="/images/objc_ivar.png" alt="objc_iva"></p><p>使用 <code>clang -rewrite-objc BBObject.m</code> 可以把得到重写后的 C++ 文件，在其中也可以看到其中获取属性就是自身地址加偏移量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * _I_BBObject_bb_name(BBObject * <span class="keyword">self</span>, SEL _cmd) &#123; </span><br><span class="line">    <span class="keyword">return</span> (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_BBObject$_bb_name)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Objc-中类和对象的本质&quot;&gt;&lt;a href=&quot;#Objc-中类和对象的本质&quot; class=&quot;headerlink&quot; title=&quot;Objc 中类和对象的本质&quot;&gt;&lt;/a&gt;Objc 中类和对象的本质&lt;/h2&gt;&lt;p&gt;Objc 中任何对象都可以称之为 &lt;code&gt;id&lt;/code&gt; 类型，那么看下在 &lt;code&gt;objc.h&lt;/code&gt; 对 &lt;code&gt;id&lt;/code&gt; 类型的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// A pointer to an instance of a class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;objc_object&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;id&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注释中的描述是 &lt;em&gt;一个指向类的实例的指针&lt;/em&gt;，那么是不是意味一个类的实例即对象就是一个 &lt;code&gt;objc_object&lt;/code&gt; 结构体呢？再看源码：&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="runtime" scheme="http://blog.iosgg.cn/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + coding 博客的搭建和优化</title>
    <link href="http://blog.iosgg.cn/2016/03/27/3-make-blog-use-githubPages-hexo/"/>
    <id>http://blog.iosgg.cn/2016/03/27/3-make-blog-use-githubPages-hexo/</id>
    <published>2016-03-27T07:01:04.000Z</published>
    <updated>2022-06-24T17:09:19.690Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hexo-next-arao-edit.jpg" alt="hexo-next-arao-edit"></p><p><del> 以后会持续更新的~ </del></p><p>博客在于内容而不在于形式，反反复复折腾体验了几个主题。以后或许便会稳定不在折腾。</p><a id="more"></a><hr><p>前段时间用Github上Pages服务配合Hexo搭建了自己的博客，后来整理下记录下过程。<br><del>后来将主题换为 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next</a> </del>（最终是使用<a href="https://github.com/sanyucz/hexo-theme-fexo" target="_blank" rel="noopener">fexo</a>），所以更新一下，方便后来人，<del>也便于自己再用到来查看</del></p><p>从写博客到在网页上展示的过程是这样的，用MarkDown写下自己的博客内容，通过Hexo生成静态的HTML网页，然后push（git源代码管理工具提交）到 <a href="https://coding.net/" target="_blank" rel="noopener">coding</a>/<a href="https://github.com/" target="_blank" rel="noopener">Github</a> 上你的代码仓库，再通过代码托管平台的Pages服务发布到网上。</p><!--more--><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><h3 id="博客搭建的准备工作"><a href="#博客搭建的准备工作" class="headerlink" title="博客搭建的准备工作"></a>博客搭建的准备工作</h3><p><strong>步骤：</strong></p><ul><li>申请 Github/coding 账号，然后新建一个 <code>github_username.github.io</code> 的仓库，比如我的Github用户名是 <code>sanyucz</code> ，所以仓库名称就是 <code>sanyucz.github.io</code> ，这个名字是要严格遵守的，搭建完成后也是在浏览器中直接通过 <a href="https://sanyucz.github.io" target="_blank" rel="noopener">https://sanyucz.github.io</a> 来访问自己的博客。同样的 coding 上直接新建一个用户名的仓库，比如我的就是 <code>sanyucz</code> ，搭建完成之后可以通过 <a href="https://sanyucz.coding.me" target="_blank" rel="noopener">https://sanyucz.coding.me</a> 来访问。</li><li>在Github/coding中加入自己电脑的 ssh。</li><li>安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a></li><li>安装 <a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">homebrew</a></li><li>安装 Hexo，参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档</a></li></ul><h3 id="开始搭建博客"><a href="#开始搭建博客" class="headerlink" title="开始搭建博客"></a>开始搭建博客</h3><p>当 Hexo 也安装好之后执行以下命令来搭建本地博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;&#x2F;&#x2F; &lt;folder&gt; 是博客的本地路径</span><br><span class="line">$ cd &lt;folder&gt; &#x2F;&#x2F; cd 切换目录到博客的本地路径</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>当执行完之后，如果成功了的话，那么目录下的结构应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml&#x2F;&#x2F; 博客的配置文件</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── scripts</span><br><span class="line">├── source&#x2F;&#x2F; 博客的内容</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes&#x2F;&#x2F; 博客的主题</span><br></pre></td></tr></table></figure><p>继续在终端中输入 <strong>hexo s</strong> 会看到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;0.0.0.0:4000&#x2F;. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>这时候在浏览器中输入 <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a> 就能看到自己的博客了，<br>停止服务摁下 <code>Ctrl + C</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Hexo 常用的命令</span><br><span class="line">hexo s &#x2F;&#x2F; hexo server 开启本地 Hexo 服务</span><br><span class="line">hexo g &#x2F;&#x2F; hexo generate 生成本地 html js</span><br><span class="line">hexo d &#x2F;&#x2F; hexo deploy 发布到远程仓库</span><br><span class="line">hexo c &#x2F;&#x2F; hexo clean 删除generate生成的文件和缓存</span><br><span class="line">hexo n &#x2F;&#x2F; hexo new,用于新建一篇文章 eg: hexo new &quot;我的第一篇博客&quot;</span><br></pre></td></tr></table></figure><h3 id="配置-Hexo"><a href="#配置-Hexo" class="headerlink" title="配置 Hexo"></a>配置 Hexo</h3><p>Hexo 的配置文件有两个，其中一个是在博客目录下的 <code>_config.yml</code>，另外一个在 <code>blog/theme/your_theme/_config.yml</code> ，从位置就可以看出来，在博客目录下的主要是配置博客站点信息，比如所博客的title，作者等。在主题目录下多是配置主题样式相关，关于主题，下面再讲。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class="line">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class="line"># Site</span><br><span class="line">title: 王修斌的技术博客&#x2F;&#x2F; 博客标题</span><br><span class="line">subtitle: 与肝胆人共事，无字句处读书&#x2F;&#x2F; 博客子标题</span><br><span class="line">description: 爱生活、爱编程，爱学习，爱折腾。&#x2F;&#x2F; 博客的描叙</span><br><span class="line">author: sanyucz&#x2F;&#x2F; 作者</span><br><span class="line">language: zh-CN&#x2F;&#x2F; 默认语言</span><br><span class="line">timezone:</span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;sanyucz.github.io&#x2F; &#x2F;&#x2F; 博客的地址</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; &#x2F;&#x2F; 时间格式</span><br><span class="line">permalink_defaults:</span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10&#x2F;&#x2F; 博客列表每页显示博客的数量</span><br><span class="line">pagination_dir: page</span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">#RSS订阅</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-baidu-sitemap</span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line"># theme: hexo-theme-next</span><br><span class="line"># theme: hexo-theme-material</span><br><span class="line">theme: jacman&#x2F;&#x2F; 博客的主题</span><br><span class="line">stylus:</span><br><span class="line">  compress: true</span><br><span class="line">&#x2F;&#x2F; 博客评论 一般是多说和disqus，disqus是世界主流，在国内大多用多说，原因你懂得，这里两个都用了</span><br><span class="line">duoshuo_shortname: sanyucz</span><br><span class="line">disqus_shortname: sanyucz</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">&#x2F;&#x2F; 远程仓库配置 这里我是推送到 coding 和 github 两个平台的仓库，所以配置了两个</span><br><span class="line">deploy:</span><br><span class="line">      type: git</span><br><span class="line">      repo: </span><br><span class="line">          github: git@github.com:sanyucz&#x2F;sanyucz.github.io.git,master</span><br><span class="line">          coding: git@git.coding.net:sanyucz&#x2F;sanyucz.git,master</span><br><span class="line">      # branch: master</span><br><span class="line">      # message: github</span><br></pre></td></tr></table></figure><h3 id="为博客安装插件"><a href="#为博客安装插件" class="headerlink" title="为博客安装插件"></a>为博客安装插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure><p>插件的作用各不相同，有的是用来生成RSS订阅，有的是压缩 js/CSS。<br>各种插件的安装推荐查看我所使用的 Jacman 主题的作者写的文章：<a href="http://jacman.wuchong.me/2014/11/20/how-to-use-jacman/" target="_blank" rel="noopener">如何使用 Jacman 主题</a></p><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>Hexo 自带的主题太过于简单，这里推荐使用 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a>。简洁，但不简单。<br>下载下来重命名为 <code>next</code> 并放到 blog/theme 下面，修改 站点配置文件 <code>blog/_config.yml</code> 中的 <code>theme</code> 字段： <code>theme: next</code>，注意冒号之后要有空格。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>从万网（阿里域名）买了三年的<strong>top</strong>域名，三年也不过就一包烟钱而已，买过域名之后需要解析，解析是为了访问域名可以直接访问我们的博客。<br>在阿里域名注册并登陆之后，点击 控制台-域名-解析，解析如下：<br>![/images/aliyuming.png)</p><p>因为国内访问 Github 很慢，所以我默认访问的是coding上的博客。如果只在Github上面托管了博客，那么只需要解析一条默认的就好，需要注意的是域名后面有个 ‘ <strong>.</strong> ’。解析成功之后等待几分钟就可以通过域名来访问博客啦。</p><h2 id="搭建中遇到的错误"><a href="#搭建中遇到的错误" class="headerlink" title="搭建中遇到的错误"></a>搭建中遇到的错误</h2><h3 id="DTraceProviderBindings-错误"><a href="#DTraceProviderBindings-错误" class="headerlink" title="DTraceProviderBindings 错误"></a><code>DTraceProviderBindings</code> 错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [Error: Cannot find module &#39;.&#x2F;build&#x2F;Release&#x2F;DTraceProviderBindings&#39;] code: &#39;MODULE_NOT_FOUND&#39; &#125;</span><br><span class="line">&#123; [Error: Cannot find module &#39;.&#x2F;build&#x2F;default&#x2F;DTraceProviderBindings&#39;] code: &#39;MODULE_NOT_FOUND&#39; &#125;</span><br><span class="line">&#123; [Error: Cannot find module &#39;.&#x2F;build&#x2F;Debug&#x2F;DTraceProviderBindings&#39;] code: &#39;MODULE_NOT_FOUND&#39; &#125;</span><br></pre></td></tr></table></figure><p>试过官网建议 <code>npm install hexo --no-optional</code>，不行。<br>网上说的删除插件<del>~</del>，什么鬼？</p><p>最后我直接把引起错误的代码给注释了，根据报错信息，定位到<code>dtrace-provider.js</code>，<br>注释其中内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var builds &#x3D; [&#39;Release&#39;, &#39;default&#39;, &#39;Debug&#39;];</span><br><span class="line">for (var i in builds) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var binding &#x3D; require(&#39;.&#x2F;build&#x2F;&#39; + builds[i] + &#39;&#x2F;DTraceProviderBindings&#39;);</span><br><span class="line">        DTraceProvider &#x3D; binding.DTraceProvider;</span><br><span class="line">        break;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        &#x2F;&#x2F; if the platform looks like it _should_ have DTrace</span><br><span class="line">        &#x2F;&#x2F; available, log a failure to load the bindings.</span><br><span class="line">        if (process.platform &#x3D;&#x3D; &#39;darwin&#39; ||</span><br><span class="line">            process.platform &#x3D;&#x3D; &#39;sunos&#39; ||</span><br><span class="line">            process.platform &#x3D;&#x3D; &#39;freebsd&#39;) &#123;</span><br><span class="line">            console.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，继续搞起！</p><h2 id="博客的优化"><a href="#博客的优化" class="headerlink" title="博客的优化"></a>博客的优化</h2><p>虽然博客已经搭建起来，并且有了一个好看的主题，但是很多时候还是显得过于千篇一律。</p><h3 id="访问速度优化"><a href="#访问速度优化" class="headerlink" title="访问速度优化"></a>访问速度优化</h3><p>尝试了多种的优化方式，我觉得最简单、效果最好的就是，只在Github上托管的博客，最好在coding上也托管一份，毕竟coding是国内的，访问速度上要快很多。<br>另外再推荐一个压缩页面的插件：<code>gulp</code>，具体使用请另行百度。<br>其他方式：</p><ul><li><a href="http://joryhe.coding.me/2016-06-05-hexo_site_seo_speed_more_optimization.html" target="_blank" rel="noopener">Hexo博客优化，如何加快你的博客访问速度</a></li><li><a href="https://github.com/iissnan/hexo-theme-next/issues/886" target="_blank" rel="noopener">使用google字体影响了网页加载效率</a></li></ul><h3 id="访客、工具箱以及其他效果"><a href="#访客、工具箱以及其他效果" class="headerlink" title="访客、工具箱以及其他效果"></a>访客、工具箱以及其他效果</h3><ul><li><a href="http://www.yanglonglong.com/blog/2016-04-19-%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2.html" target="_blank" rel="noopener">工具箱-使用hexo搭建自己的独立博客</a></li><li><a href="http://ehlxr.me/2016/08/30/%E4%BD%BF%E7%94%A8Hexo%E5%9F%BA%E4%BA%8EGitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/#%E5%85%AB%E3%80%81%E5%9B%BE%E7%89%87%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">使用Hexo基于GitHub Pages搭建个人博客</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/hexo-next-arao-edit.jpg&quot; alt=&quot;hexo-next-arao-edit&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt; 以后会持续更新的~ &lt;/del&gt;&lt;/p&gt;
&lt;p&gt;博客在于内容而不在于形式，反反复复折腾体验了几个主题。以后或许便会稳定不在折腾。&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://blog.iosgg.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Hexo" scheme="http://blog.iosgg.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Git 使用手册</title>
    <link href="http://blog.iosgg.cn/2016/03/25/2-git_basic/"/>
    <id>http://blog.iosgg.cn/2016/03/25/2-git_basic/</id>
    <published>2016-03-25T02:14:49.000Z</published>
    <updated>2022-06-24T17:09:19.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h3><p>Git 配置变量存放在以下三个不同的地方：（摘自<a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">1.5 起步 - 初次运行 Git 前的配置</a>）</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 <code>--global</code> 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Sanyucz&quot;</span><br><span class="line">$ git config --global user.email kingxiubin@gmail.com</span><br><span class="line">    </span><br><span class="line">要检查已有的配置信息，可以使用 git config --list 命令</span><br></pre></td></tr></table></figure><h3 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 暂存</span><br><span class="line">git stash</span><br><span class="line">&#x2F;&#x2F; 查看所有暂存信息</span><br><span class="line">gi stash list</span><br><span class="line">&#x2F;&#x2F; 恢复 stash@&#123;0&#125;</span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h3 id="创建、删除版本库"><a href="#创建、删除版本库" class="headerlink" title="创建、删除版本库"></a>创建、删除版本库</h3><p>版本库（仓库<code>repository</code>）的创建和文件添加与提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化仓库</span><br><span class="line">git init</span><br><span class="line">&#x2F;&#x2F; fileName 是要添加的文件 添加所有可以用通配符 *</span><br><span class="line">git add &lt;fileName&gt;</span><br><span class="line">&#x2F;&#x2F; 提交到本地，message是提交的信息</span><br><span class="line">git commit -m &quot;&lt;message&gt;&quot;</span><br><span class="line">&#x2F;&#x2F; 删除本地仓库</span><br><span class="line">find . -name &quot;.git&quot; | xargs rm -Rf</span><br></pre></td></tr></table></figure><!--more--><h3 id="查看版本库和文件信息"><a href="#查看版本库和文件信息" class="headerlink" title="查看版本库和文件信息"></a>查看版本库和文件信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看仓库状态: git status</span><br><span class="line">git status</span><br><span class="line">&#x2F;&#x2F; 如果要查看具体内容：git diff</span><br><span class="line">git diff readme.txt</span><br><span class="line">&#x2F;&#x2F; 查看conmmit的历史记录：git log</span><br><span class="line">git log</span><br><span class="line">&#x2F;&#x2F; 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 --pretty&#x3D;oneline 参数：</span><br><span class="line">git log --pretty&#x3D;oneline</span><br><span class="line">&#x2F;&#x2F; 查询历史命令：git reflog</span><br><span class="line">git reflog</span><br><span class="line">&#x2F;&#x2F; 查看工作区和仓库文件的区别</span><br><span class="line">git diff HEAD -- &lt; fileName &gt;</span><br></pre></td></tr></table></figure><h3 id="版本回退和撤销修改"><a href="#版本回退和撤销修改" class="headerlink" title="版本回退和撤销修改"></a>版本回退和撤销修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 回退上一版本：</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">&#x2F;&#x2F; 回退指定版本：3628164 是用 git log 查询出来的版本数值</span><br><span class="line">git reset --hard 3628164</span><br><span class="line">&#x2F;&#x2F; 放弃修改文件</span><br><span class="line">git checkout -- file</span><br><span class="line">&#x2F;&#x2F;可以把已被添加到暂存区的 &#39;file&#39; 移到工作区</span><br><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure><h3 id="远程仓库和分支管理"><a href="#远程仓库和分支管理" class="headerlink" title="远程仓库和分支管理"></a>远程仓库和分支管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 克隆远程仓库</span><br><span class="line">git clone &lt;url&gt;</span><br><span class="line">&#x2F;&#x2F; 添加远程仓库</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;sanyucz&#x2F;cocoachina-ios-app.git</span><br><span class="line">&#x2F;&#x2F; 设置默认远程仓库 -u ： --set-upstream</span><br><span class="line">git push -u origin master</span><br><span class="line">&#x2F;&#x2F; 删除远程仓库</span><br><span class="line">git remote rm origin</span><br><span class="line">&#x2F;&#x2F; 创建dev分支，然后切换到dev分支：</span><br><span class="line">git checkout -b dev</span><br><span class="line">&#x2F;&#x2F; 和下面两条命令等同：</span><br><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br><span class="line">&#x2F;&#x2F; 查看当前分支：</span><br><span class="line">git branch</span><br><span class="line">&#x2F;&#x2F; 把 &#39;dev&#39; 分支合并到主分支然后再删除 &#39;dev&#39; 分支</span><br><span class="line">git merge dev</span><br><span class="line">git branch -d dev</span><br><span class="line">&#x2F;&#x2F; 删除远程分支：（其实是把一个空分支push到远程某个分支）</span><br><span class="line">git push origin :dev</span><br></pre></td></tr></table></figure><h3 id="撒销一个合并"><a href="#撒销一个合并" class="headerlink" title="撒销一个合并"></a>撒销一个合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果你想把当前的修改都放弃，可以用下面的命令回到合并之前的状态:</span><br><span class="line">git reset --hard HEAD</span><br><span class="line">&#x2F;&#x2F; 如果你已经把合并后的代码提交，但还是想把它们撒销：</span><br><span class="line">git reset --hard ORIG_HEAD</span><br><span class="line">&#x2F;&#x2F; 再如果你不光把代码提交，你提交之后又做了新的修改，又不想放弃修改</span><br><span class="line">&#x2F;&#x2F; HEAD 合并的那个 版本号</span><br><span class="line">git revert -m 1 HEAD</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0 &#x2F;&#x2F; 打标签到当前分支最新的 commit 上</span><br><span class="line">git tag v0.9 6224937 &#x2F;&#x2F; 打标签到当 head 为 6224937 的 commit 上</span><br><span class="line">git tag &#x2F;&#x2F; 查看标签</span><br><span class="line">git show &lt;tagname&gt; &#x2F;&#x2F; 查看标签信息</span><br><span class="line">git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 &#x2F;&#x2F; -a指定标签名，-m指定说明文字</span><br><span class="line">git tag -d v0.1 &#x2F;&#x2F; 删除标签</span><br><span class="line">git push origin &lt;tagname&gt; &#x2F;&#x2F; 推送某个标签到远程</span><br><span class="line">git push origin --tags &#x2F;&#x2F; 推送到远程的本地标签</span><br><span class="line">git tag -d v0.9 &#x2F;&#x2F; 加上下个命令删除远程的标签</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;v0.9</span><br></pre></td></tr></table></figure><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>一般可以：<code>co</code> 表示 <code>checkout</code> ，<code>ci</code> 表示 <code>commit</code> ，<code>br</code> 表示 <code>branch</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">&#x2F;&#x2F; 一个丧心病狂的别名配置：</span><br><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure><h3 id="GIT-的配置"><a href="#GIT-的配置" class="headerlink" title="GIT 的配置"></a>GIT 的配置</h3><ol><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 / <code>etc/gitconfig</code> 中的同名变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;John Doe&quot;</span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure></li></ol><h2 id="Git图解"><a href="#Git图解" class="headerlink" title="Git图解"></a>Git图解</h2><blockquote><p>廖大的图实在是太通俗易懂了，无耻盗图ing..</p></blockquote><p><img src="/images/c1f0660egw1f4uwylx5hdj20cq06iaa8.jpg" alt="Git结构示意图"><br>Git的版本库里面有个 <code>stage</code>（暂存区），我们平时工作的文档目录是工作区，对文件有了修改执行 <code>git add</code> 命令就会把变化的文件添加到版本库的暂存区，再执行 <code>git commit</code> 才会把文件从暂存区添加到当前分支。<br><code>stage</code> (暂存区)在物理上的路径是 <code>.git/index</code> ，文件存储的是每次的修改。</p><p>而 <code>HEAD</code> 其实是一个指向当前分支的指针，</p><p><img src="/images/c1f0660egw1f4v44cy87wj208d047q2w.jpg" alt="Git HEAD指针"></p><p>当创建了 <code>dev</code> 分支的时候，是创建了一个 <code>dev</code> 指针，并且直接把 <code>HEAD</code> 指向 <code>dev</code> 指针。</p><p><img src="/images/c1f0660egw1f4v4901tvfj20a706h74a.jpg" alt="Git 创建分支"></p><p>当合并分支的时候直接把主分支 <code>master</code> 指向 <code>dev</code> 分支。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Git常用命令&quot;&gt;&lt;a href=&quot;#Git常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git常用命令&quot;&gt;&lt;/a&gt;Git常用命令&lt;/h2&gt;&lt;h3 id=&quot;Git-配置&quot;&gt;&lt;a href=&quot;#Git-配置&quot; class=&quot;headerlink&quot; title=&quot;Git 配置&quot;&gt;&lt;/a&gt;Git 配置&lt;/h3&gt;&lt;p&gt;Git 配置变量存放在以下三个不同的地方：（摘自&lt;a href=&quot;https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1.5 起步 - 初次运行 Git 前的配置&lt;/a&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/gitconfig&lt;/code&gt; 文件：系统中对所有用户都普遍适用的配置。若使用 &lt;code&gt;git config&lt;/code&gt; 时用 &lt;code&gt;--system&lt;/code&gt; 选项，读写的就是这个文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.gitconfig&lt;/code&gt; 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 &lt;code&gt;--global&lt;/code&gt; 选项，读写的就是这个文件。&lt;/li&gt;
&lt;li&gt;当前项目的 Git 目录中的配置文件（也就是工作目录中的 &lt;code&gt;.git/config&lt;/code&gt; 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 &lt;code&gt;.git/config&lt;/code&gt; 里的配置会覆盖 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 中的同名变量。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="软件开发" scheme="http://blog.iosgg.cn/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Git" scheme="http://blog.iosgg.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>H5笔记之CSS</title>
    <link href="http://blog.iosgg.cn/2016/02/22/1-CSS-with-H5/"/>
    <id>http://blog.iosgg.cn/2016/02/22/1-CSS-with-H5/</id>
    <published>2016-02-22T11:38:46.000Z</published>
    <updated>2022-06-24T17:09:19.688Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 全称是<strong>Cascading Style Sheets</strong>，层叠样式表，被用来控制HTML标签的样式，美化网页<br>。CSS有两个重点： <strong>属性</strong> 和 <strong>选择器</strong> 。</p><h4 id="CCS的编写格式"><a href="#CCS的编写格式" class="headerlink" title="CCS的编写格式"></a>CCS的编写格式</h4><p>CCS的编写格式是以键值对的形式，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">color</span> : <span class="selector-tag">red</span>;</span><br><span class="line"><span class="selector-tag">background-color</span> : <span class="selector-tag">blue</span>;</span><br><span class="line"><span class="selector-tag">font-size</span> : 20<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><ul><li>属性一般由属性名和属性值组成，左边是属性名，右边是属性的值</li></ul><a id="more"></a><h4 id="CSS有3种书写形式："><a href="#CSS有3种书写形式：" class="headerlink" title="CSS有3种书写形式："></a>CSS有3种书写形式：</h4><ol><li>行内样式：（内联样式）直接在标签的 <strong>style</strong> 属性中书写</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body style="color : red;"&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>页内样式：在本网页的 <strong>style</strong>标签中书写</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>外部样式：在单独的CSS文件中书写，然后在网页中用link引入</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="stylesheet" href="index.css"&gt;</span><br></pre></td></tr></table></figure><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器:"></a>CSS选择器:</h4><h5 id="1-标签选择器"><a href="#1-标签选择器" class="headerlink" title="1. 标签选择器"></a>1. 标签选择器</h5><p>根据标签名查找标签：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;<span class="selector-tag">div1</span>&lt;<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>找到标签，设置样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-类选择器"><a href="#2-类选择器" class="headerlink" title="2. 类选择器"></a>2. 类选择器</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class="high"&gt;hello world&lt;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.high</span>&#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-id选择器"><a href="#3-id选择器" class="headerlink" title="3. id选择器"></a>3. id选择器</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id="first"&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#first</span>&#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-并列选择器"><a href="#4-并列选择器" class="headerlink" title="4. 并列选择器"></a>4. 并列选择器</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="high"&gt;div high&lt;/div&gt;</span><br><span class="line">&lt;div class="low"&gt;div low&lt;/div&gt;</span><br><span class="line">&lt;p class="high"&gt;p high&lt;/p&gt;</span><br><span class="line">&lt;p class="low"&gt;p low&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>, <span class="selector-class">.high</span>&#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并列选择，只要一个符合条件就可以<br>结果：</p><div style="text-align:center;background-color:lightgray" ><font color=red>div high</font><br><font color=red>div low</font><br><font color=red>p high</font><br><font color=black>p low</font><br></div><h5 id="5-复合选择器"><a href="#5-复合选择器" class="headerlink" title="5. 复合选择器"></a>5. 复合选择器</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="high"&gt;div high&lt;/div&gt;</span><br><span class="line">&lt;div class="low"&gt;div low&lt;/div&gt;</span><br><span class="line">&lt;p class="high"&gt;p high&lt;/p&gt;</span><br><span class="line">&lt;p class="low"&gt;p low&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-class">.high</span>&#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复合选择，必须全部符合条件就可以<br>结果：</p><div style="text-align:center;background-color:lightgray" ><font color=red>div high</font><br><font color=black>div low</font><br><font color=black>p high</font><br><font color=black>p low</font><br></div><h5 id="6-后代选择器"><a href="#6-后代选择器" class="headerlink" title="6. 后代选择器"></a>6. 后代选择器</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;div -&gt; p&lt;/p&gt;</span><br><span class="line">&lt;<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;p&gt;div -&gt; span -&gt; p&lt;/p&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;div p&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要是在<strong>div</strong> 里面的 <strong>p</strong> 标签，都符合要求，结果：</p><div style="text-align:center;background-color:lightgray" ><font color=red>div -> p</font><br><font color=red>div -> span -> p</font><br><font color=black>div p</font><br></div><h5 id="7-直接后代选择器"><a href="#7-直接后代选择器" class="headerlink" title="7. 直接后代选择器"></a>7. 直接后代选择器</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;div -&gt; p&lt;/p&gt;</span><br><span class="line">&lt;<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;p&gt;div -&gt; span -&gt; p&lt;/p&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须是直接在<strong>div</strong> 里面的 <strong>p</strong> 标签，才符合要求，即儿子可以，孙子就不行<br>结果：</p><div style="text-align:center;background-color:lightgray" ><font color=red>div -> p</font><br><font color=black>div -> span -> p</font><br></div><h5 id="8-相邻兄弟选择器"><a href="#8-相邻兄弟选择器" class="headerlink" title="8. 相邻兄弟选择器"></a>8. 相邻兄弟选择器</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;div -&gt; p&lt;/p&gt;</span><br><span class="line">&lt;<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;p&gt;div -&gt; span -&gt; p&lt;/p&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;div p&lt;/p&gt;</span><br><span class="line">&lt;p&gt;p p&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要是在<strong>div</strong> 里面的 <strong>p</strong> 标签，都符合要求，结果：</p><div style="text-align:center;background-color:lightgray" ><font color=black>div -> p</font><br><font color=black>div -> span -> p</font><br><font color=red>div p</font><br><font color=black>p p</font><br></div><h5 id="9-属性选择器"><a href="#9-属性选择器" class="headerlink" title="9. 属性选择器"></a>9. 属性选择器</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name="Jack"&gt;name = Jack&lt;/div&gt;</span><br><span class="line">&lt;div name="Tom"&gt;name = Tom&lt;/div&gt;</span><br><span class="line">&lt;div name="Bob" age="20"&gt;name = Bob, age = 20&lt;/div&gt;</span><br><span class="line">&lt;div&gt;no name&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[name]</span> &#123;</span><br><span class="line"><span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[name]</span><span class="selector-attr">[age]</span> &#123;</span><br><span class="line"><span class="attribute">color </span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[name=<span class="string">"Tom"</span>]</span> &#123;</span><br><span class="line"><span class="attribute">color </span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="text-align:center;background-color:lightgray" ><font color=red>name = Jack</font><br><font color=yellow>name = Tom</font><br><font color=green>name = Bob, age = 20</font><br><font color=black>no name</font><br></div><h5 id="10-伪类"><a href="#10-伪类" class="headerlink" title="10. 伪类"></a>10. 伪类</h5><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>:active</td><td>向被激活的的元素添加样式</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h5 id="11-伪元素"><a href="#11-伪元素" class="headerlink" title="11. 伪元素"></a>11. 伪元素</h5><p>…</p><h4 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h4><p>选择器针对性越强、范围越小，优先级就越高<br>选择器的权值：</p><table><thead><tr><th>选择器</th><th>权值</th></tr></thead><tbody><tr><td>通配符</td><td>0</td></tr><tr><td>标签</td><td>1</td></tr><tr><td>类</td><td>10</td></tr><tr><td>属性</td><td>10</td></tr><tr><td>伪类</td><td>10</td></tr><tr><td>id</td><td>100</td></tr><tr><td>important</td><td>1000</td></tr></tbody></table><ul><li>原则：选择器的权值加在一起，大的优先，权值一样，后定义的优先</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS 全称是&lt;strong&gt;Cascading Style Sheets&lt;/strong&gt;，层叠样式表，被用来控制HTML标签的样式，美化网页&lt;br&gt;。CSS有两个重点： &lt;strong&gt;属性&lt;/strong&gt; 和 &lt;strong&gt;选择器&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;CCS的编写格式&quot;&gt;&lt;a href=&quot;#CCS的编写格式&quot; class=&quot;headerlink&quot; title=&quot;CCS的编写格式&quot;&gt;&lt;/a&gt;CCS的编写格式&lt;/h4&gt;&lt;p&gt;CCS的编写格式是以键值对的形式，如：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;color&lt;/span&gt; : &lt;span class=&quot;selector-tag&quot;&gt;red&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;background-color&lt;/span&gt; : &lt;span class=&quot;selector-tag&quot;&gt;blue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;font-size&lt;/span&gt; : 20&lt;span class=&quot;selector-tag&quot;&gt;px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;属性一般由属性名和属性值组成，左边是属性名，右边是属性的值&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://blog.iosgg.cn/categories/iOS/"/>
    
    
    <category term="H5" scheme="http://blog.iosgg.cn/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>序言</title>
    <link href="http://blog.iosgg.cn/2016/02/20/0-blog-preface/"/>
    <id>http://blog.iosgg.cn/2016/02/20/0-blog-preface/</id>
    <published>2016-02-20T10:38:45.000Z</published>
    <updated>2022-06-24T17:09:19.687Z</updated>
    
    <content type="html"><![CDATA[<p>记得刚从事工作的时候，经常性的会遇到困难而不知所措。幸而在网上能找到很多牛人前辈们的技术博客能将问题和开发中的知识深入浅出的剖析，给予了我很大的帮助。于是，那会我便下定决心以后有机会一定要写自己的博客。</p><p>写这个博客主要作为学习以用，记录自己在生活、学习和工作中的点点滴滴。</p><p>既可以温故而知新，也可查漏补缺，方便自己回头查找使用方便，或能帮助他人也是好的。</p><blockquote><p>Update： 或许可以构架自己技术知识体系？en…</p></blockquote><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;记得刚从事工作的时候，经常性的会遇到困难而不知所措。幸而在网上能找到很多牛人前辈们的技术博客能将问题和开发中的知识深入浅出的剖析，给予了我很大的帮助。于是，那会我便下定决心以后有机会一定要写自己的博客。&lt;/p&gt;
&lt;p&gt;写这个博客主要作为学习以用，记录自己在生活、学习和工作中的点点滴滴。&lt;/p&gt;
&lt;p&gt;既可以温故而知新，也可查漏补缺，方便自己回头查找使用方便，或能帮助他人也是好的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Update： 或许可以构架自己技术知识体系？en…&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
