<!DOCTYPE html><html lang="zh-ch"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS Hybrid 的实践 · 阿斌的技术博客</title><meta name="description" content="iOS Hybrid 的实践 - Abin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.iosgg.cn/atom.xml" title="阿斌的技术博客"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="阿斌的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/wxiubin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS Hybrid 的实践</h1><div class="post-info">Sep 3, 2018</div><div class="post-content"><p>iOS Hybrid 相关大致上有以下几块内容：</p>
<ol>
<li>基础能力支持，H5 和 native 的互相通信能力</li>
<li>业务支撑，Bridge 的协议制定</li>
<li>性能优化，hybrid 离线能力建设</li>
<li>数据统计和性能分析以及监控</li>
</ol>
<a id="more"></a>

<h2 id="一、JavaScript-和-Native-的相互通信"><a href="#一、JavaScript-和-Native-的相互通信" class="headerlink" title="一、JavaScript 和 Native 的相互通信"></a>一、JavaScript 和 Native 的相互通信</h2><h3 id="JS-调用-Native"><a href="#JS-调用-Native" class="headerlink" title="JS 调用 Native"></a>JS 调用 Native</h3><p>业内比较好的通用做法是上下文注入，安卓 <code>addJavascriptInterface</code> 注入。iOS 使用 <code>WKWebView - scriptMessageHandler</code> 注入，这种方式注入其实只给注入对象起了一个名字<code>nativeObject</code>，这种对象只有一个函数 <code>postMessage</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;准备要传给native的数据，包括指令，数据，回调等</span><br><span class="line">var data &#x3D; &#123;</span><br><span class="line">    method:&#39;location&#39;,</span><br><span class="line">    data:&#39;http:&#x2F;&#x2F;baidu.com&#39;,</span><br><span class="line">    callback:&#39;1&#39;,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;传递给客户端</span><br><span class="line">window.webkit.messageHandlers.nativeObject.postMessage(data);</span><br></pre></td></tr></table></figure>

<p>客户端接收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    NSDictionary *msgBody &#x3D; message.body;</span><br><span class="line">    NSString *method &#x3D; msgBody[@&quot;method&quot;];</span><br><span class="line">    NSString *data &#x3D; msgBody[@&quot;data&quot;];</span><br><span class="line">    &#x2F;&#x2F; perform method with data</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还有 1. 请求拦截，2. 弹窗拦截两种方式。</p>
<p><strong>请求拦截</strong> 也可以实现 JS call Native，这是唯一一个在 iOS 上可以从 iOS 6 及以前版本支持的方案，也是唯一一个支持 Android WebView，iOS UI/WK WebView 的方案；但是这个方案有丢消息和消息长度的限制。</p>
<p>著名开源框架 <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a> 使用的就是这种通信方案。</p>
<h3 id="Native-调用-JS"><a href="#Native-调用-JS" class="headerlink" title="Native 调用 JS"></a>Native 调用 JS</h3><p>使用 <code>evaluatingJavaScript</code> 执行JS代码</p>
<p>JS 代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function calljs(data)&#123;</span><br><span class="line">    console.log(JSON.parse(data)) </span><br><span class="line">    &#x2F;&#x2F;1 识别客户端传来的数据</span><br><span class="line">    &#x2F;&#x2F;2 对数据进行分析，从而调用或执行其他逻辑  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>户端此时要调用需要在 OBJC 拼接字符串，拼出一个 JS 代码，传递的数据用 JSON</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;不展开了,data是一个字典，把字典序列化</span><br><span class="line">NSString *paramsString &#x3D; [self _serializeMessageData:data];</span><br><span class="line">NSString* javascriptCommand &#x3D; [NSString stringWithFormat:@&quot;calljs(&#39;%@&#39;);&quot;, paramsString];</span><br><span class="line">&#x2F;&#x2F;要求必须在主线程执行JS</span><br><span class="line">[self.webView evaluateJavaScript:javascriptCommand completionHandler:nil];</span><br></pre></td></tr></table></figure>

<h2 id="二、Bridge-的协议制定"><a href="#二、Bridge-的协议制定" class="headerlink" title="二、Bridge 的协议制定"></a>二、Bridge 的协议制定</h2><p>Bridge 的参数必须遵守设置规则，否则每个方法都在开发时随意设置，以后就不好统一管理。</p>
<p>比如参数最外层可以有5个：</p>
<ol>
<li>method，定位到具体是哪个方法</li>
<li>data，所有的业务参数</li>
<li>callbackId，native接收到时给 H5 的响应</li>
<li>successId，动作成功给 H5 的响应</li>
<li>failedId，动作失败给 H5 的响应，如网络请求失败</li>
</ol>
<p>那么一个正常的参数看起来是这样的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"location"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"url"</span>:<span class="string">"http://baidu.com"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"callbackId"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successId"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"failedId"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着业务的迭代，Bridge 方法会越来越多，如果 <code>method</code> 只使用一层结构的话，native 把所有的方法都放到一个类里，这个类就会越来越大，不易于维护；如果每个方法都是一个类的话，类似功能的方法之间则不能统一管理，过于离散。可以加个域的概念，比如按功能来划分，在 <code>method</code> 加入代表着功能的 <strong>域</strong>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"location.forward"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"url"</span>:<span class="string">"http://baidu.com"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"callbackId"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successId"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"failedId"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"location.close"</span>,</span><br><span class="line">    <span class="attr">"data"</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">"callbackId"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successId"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"failedId"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是随着业务的快速增长，膨胀的 APP 会划分几个业务模块，某个模块想新增 Bridge 的话，就有可能冲掉之前已有的 Bridge，比如已经存在了 <code>&quot;location.forward&quot;</code> 方法，这个时候，便可以再增加一层，对于 <code>&quot;method&quot;</code> 的约定就是：<code>模块 + 功能 + 具体的方法</code>，</p>
<p>比如电商模块想要打开某个页面，方法就是 <code>&quot;mall.location.forward&quot;</code>。当然，对于所有业务模块都需要使用的基础能力，是要放入基础Bridge中而非每个模块都自己实现一套。</p>
<h2 id="三、离线能力建设"><a href="#三、离线能力建设" class="headerlink" title="三、离线能力建设"></a>三、离线能力建设</h2><p>到了上面的那一步，基本上可以完成大部分的活动或者需求中的功能了。但是如果想用户体验更好，使用 H5 页得到近似于原生的页面时，就要想办法加快页面的加载速度，在转场动画期间尽可能减少 H5 页面白屏的时间。</p>
<p>比较优雅的方法就是提前把 H5 打包下载到本地，然后使用 <code>NSURLProtocol</code> 拦截请求把本地资源替换线上资源。但是这种方案有个问题，需要使用私有 API，具有一定的风险。使用私有 API 进行拦截，还有另外一个问题，就是 POST 请求会丢失 body，所以尽量只拦截 GET 请求。</p>
<p>到了 iOS 11 就可以使用系统提供的 <code>[setURLSchemeHandler:forURLScheme:]</code> 实现离线。<br>但 <code>WKURLSchemeHandler</code> 不能处理 Http、Https 等常规 scheme，所以需要自定义 scheme。</p>
<p>基本方案就是，在 WebView loadRequest 前判断本地是否有离线资源，支持离线且有离线资源的时候，修改 Http/Https 为自定义的 scheme，然后在 <code>NSURLProtocol</code> 或者 <code>WKURLSchemeHandler</code>去实现对本地资源的加载。</p>
<h2 id="四、数据统计和监控建设"><a href="#四、数据统计和监控建设" class="headerlink" title="四、数据统计和监控建设"></a>四、数据统计和监控建设</h2><p>doing。。</p>
<p>参考：<a href="http://www.awhisper.net/2018/03/06/hybrid-webcontainer/" target="_blank" rel="noopener">从零收拾一个hybrid框架</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/05/27/20-ios-performance/" class="prev">PREV</a><a href="/2018/03/26/18-z1-share-xcodeproj/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2022 <a href="http://blog.iosgg.cn">Abin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/m-forks/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-100885072-1",'auto');ga('send','pageview');</script></body></html>